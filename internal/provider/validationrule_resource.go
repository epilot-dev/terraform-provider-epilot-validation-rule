// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	tfTypes "github.com/epilot-dev/terraform-provider-epilot-validation-rule/internal/provider/types"
	"github.com/epilot-dev/terraform-provider-epilot-validation-rule/internal/sdk"
	speakeasy_boolvalidators "github.com/epilot-dev/terraform-provider-epilot-validation-rule/internal/validators/boolvalidators"
	speakeasy_float64validators "github.com/epilot-dev/terraform-provider-epilot-validation-rule/internal/validators/float64validators"
	speakeasy_listvalidators "github.com/epilot-dev/terraform-provider-epilot-validation-rule/internal/validators/listvalidators"
	speakeasy_objectvalidators "github.com/epilot-dev/terraform-provider-epilot-validation-rule/internal/validators/objectvalidators"
	speakeasy_stringvalidators "github.com/epilot-dev/terraform-provider-epilot-validation-rule/internal/validators/stringvalidators"
	"github.com/hashicorp/terraform-plugin-framework-validators/objectvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &ValidationRuleResource{}
var _ resource.ResourceWithImportState = &ValidationRuleResource{}

func NewValidationRuleResource() resource.Resource {
	return &ValidationRuleResource{}
}

// ValidationRuleResource defines the resource implementation.
type ValidationRuleResource struct {
	// Provider configured SDK client.
	client *sdk.SDK
}

// ValidationRuleResourceModel describes the resource data model.
type ValidationRuleResourceModel struct {
	CreatedAt      types.String                            `tfsdk:"created_at"`
	CreatedBy      types.String                            `tfsdk:"created_by"`
	ID             types.String                            `tfsdk:"id"`
	OrganizationID types.String                            `tfsdk:"organization_id"`
	Placeholder    types.String                            `tfsdk:"placeholder"`
	Rule           tfTypes.CreateValidationRuleRequestRule `tfsdk:"rule"`
	SchemaVersion  types.String                            `tfsdk:"schema_version"`
	Title          types.String                            `tfsdk:"title"`
	UpdatedAt      types.String                            `tfsdk:"updated_at"`
	UpdatedBy      types.String                            `tfsdk:"updated_by"`
}

func (r *ValidationRuleResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_validation_rule"
}

func (r *ValidationRuleResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "ValidationRule Resource",
		Attributes: map[string]schema.Attribute{
			"created_at": schema.StringAttribute{
				Computed:    true,
				Description: `ISO timestamp when the rule was created.`,
			},
			"created_by": schema.StringAttribute{
				Computed:    true,
				Description: `User ID of the creator.`,
			},
			"id": schema.StringAttribute{
				Computed:    true,
				Description: `Unique identifier for the validation rule.`,
			},
			"organization_id": schema.StringAttribute{
				Computed:    true,
				Description: `Organization ID that owns this rule.`,
			},
			"placeholder": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `Placeholder for the validation rule.`,
			},
			"rule": schema.SingleNestedAttribute{
				Required: true,
				Attributes: map[string]schema.Attribute{
					"numeric_rule_type": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"conditions": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"one": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"all": schema.ListNestedAttribute{
												Computed: true,
												Optional: true,
												NestedObject: schema.NestedAttributeObject{
													Validators: []validator.Object{
														speakeasy_objectvalidators.NotNull(),
													},
													Attributes: map[string]schema.Attribute{
														"numeric_fact_condition": schema.SingleNestedAttribute{
															Computed: true,
															Optional: true,
															Attributes: map[string]schema.Attribute{
																"four": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"fact": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Whether the input has leading zeros. Not Null; must be "has-leading-zeroes"`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																				stringvalidator.OneOf(
																					"has-leading-zeroes",
																				),
																			},
																		},
																		"operator": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Leading zeros check operator. Not Null; must be one of ["equal", "notAllowed"]`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																				stringvalidator.OneOf(
																					"equal",
																					"notAllowed",
																				),
																			},
																		},
																		"params": schema.SingleNestedAttribute{
																			Computed: true,
																			Optional: true,
																			Attributes: map[string]schema.Attribute{
																				"error_message": schema.StringAttribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `Custom error message`,
																				},
																			},
																			Description: `Additional parameters for the condition`,
																		},
																		"value": schema.BoolAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Whether leading zeros should be present or not. Not Null`,
																			Validators: []validator.Bool{
																				speakeasy_boolvalidators.NotNull(),
																			},
																		},
																	},
																	Description: `Leading zeros validation`,
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("one"),
																			path.MatchRelative().AtParent().AtName("two"),
																			path.MatchRelative().AtParent().AtName("three"),
																		}...),
																	},
																},
																"one": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"fact": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `The numeric value extracted from input; The amount of digits. Not Null; must be one of ["numeric-value", "total-length"]`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																				stringvalidator.OneOf(
																					"numeric-value",
																					"total-length",
																				),
																			},
																		},
																		"operator": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Numeric comparison operator. Not Null; must be one of ["equal", "notEqual", "lessThan", "lessThanInclusive", "greaterThan", "greaterThanInclusive"]`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																				stringvalidator.OneOf(
																					"equal",
																					"notEqual",
																					"lessThan",
																					"lessThanInclusive",
																					"greaterThan",
																					"greaterThanInclusive",
																				),
																			},
																		},
																		"params": schema.SingleNestedAttribute{
																			Computed: true,
																			Optional: true,
																			Attributes: map[string]schema.Attribute{
																				"error_message": schema.StringAttribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `Custom error message`,
																				},
																			},
																			Description: `Additional parameters for the condition`,
																		},
																		"value": schema.Float64Attribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Numeric value to compare against. Not Null`,
																			Validators: []validator.Float64{
																				speakeasy_float64validators.NotNull(),
																			},
																		},
																	},
																	Description: `Numeric value comparison`,
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("two"),
																			path.MatchRelative().AtParent().AtName("three"),
																			path.MatchRelative().AtParent().AtName("four"),
																		}...),
																	},
																},
																"three": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"fact": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Count of decimal digits. Not Null; must be "decimal-digits-count"`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																				stringvalidator.OneOf(
																					"decimal-digits-count",
																				),
																			},
																		},
																		"operator": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Decimal digit count comparison operator. Not Null; must be one of ["equal", "minDecimalDigits", "maxDecimalDigits"]`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																				stringvalidator.OneOf(
																					"equal",
																					"minDecimalDigits",
																					"maxDecimalDigits",
																				),
																			},
																		},
																		"params": schema.SingleNestedAttribute{
																			Computed: true,
																			Optional: true,
																			Attributes: map[string]schema.Attribute{
																				"error_message": schema.StringAttribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `Custom error message`,
																				},
																			},
																			Description: `Additional parameters for the condition`,
																		},
																		"value": schema.Float64Attribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Expected number of decimal digits. Not Null`,
																			Validators: []validator.Float64{
																				speakeasy_float64validators.NotNull(),
																			},
																		},
																	},
																	Description: `Decimal digits count validation`,
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("one"),
																			path.MatchRelative().AtParent().AtName("two"),
																			path.MatchRelative().AtParent().AtName("four"),
																		}...),
																	},
																},
																"two": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"fact": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Count of integer digits (excludes leading zeros unless allowed). Not Null; must be "integer-digits-count"`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																				stringvalidator.OneOf(
																					"integer-digits-count",
																				),
																			},
																		},
																		"operator": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Digit count comparison operator. Not Null; must be one of ["equal", "exactlyNDigits", "minIntegerDigits", "maxIntegerDigits"]`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																				stringvalidator.OneOf(
																					"equal",
																					"exactlyNDigits",
																					"minIntegerDigits",
																					"maxIntegerDigits",
																				),
																			},
																		},
																		"params": schema.SingleNestedAttribute{
																			Computed: true,
																			Optional: true,
																			Attributes: map[string]schema.Attribute{
																				"allow_leading_zeroes": schema.BoolAttribute{
																					Computed:    true,
																					Optional:    true,
																					Default:     booldefault.StaticBool(false),
																					Description: `Whether to count leading zeroes in digit count. Default: false`,
																				},
																				"error_message": schema.StringAttribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `Custom error message`,
																				},
																			},
																			Description: `Additional parameters for the condition`,
																		},
																		"value": schema.Float64Attribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Expected number of integer digits. Not Null`,
																			Validators: []validator.Float64{
																				speakeasy_float64validators.NotNull(),
																			},
																		},
																	},
																	Description: `Integer digits count validation`,
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("one"),
																			path.MatchRelative().AtParent().AtName("three"),
																			path.MatchRelative().AtParent().AtName("four"),
																		}...),
																	},
																},
															},
															Description: `Fact-based condition for numeric validation`,
															Validators: []validator.Object{
																objectvalidator.ConflictsWith(path.Expressions{
																	path.MatchRelative().AtParent().AtName("numeric_nested_condition"),
																}...),
															},
														},
														"numeric_nested_condition": schema.SingleNestedAttribute{
															Computed: true,
															Optional: true,
															Attributes: map[string]schema.Attribute{
																"one": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"all": schema.ListNestedAttribute{
																			Computed: true,
																			Optional: true,
																			NestedObject: schema.NestedAttributeObject{
																				Validators: []validator.Object{
																					speakeasy_objectvalidators.NotNull(),
																				},
																				Attributes: map[string]schema.Attribute{
																					"four": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"fact": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Whether the input has leading zeros. Not Null; must be "has-leading-zeroes"`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"has-leading-zeroes",
																									),
																								},
																							},
																							"operator": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Leading zeros check operator. Not Null; must be one of ["equal", "notAllowed"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"equal",
																										"notAllowed",
																									),
																								},
																							},
																							"params": schema.SingleNestedAttribute{
																								Computed: true,
																								Optional: true,
																								Attributes: map[string]schema.Attribute{
																									"error_message": schema.StringAttribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `Custom error message`,
																									},
																								},
																								Description: `Additional parameters for the condition`,
																							},
																							"value": schema.BoolAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Whether leading zeros should be present or not. Not Null`,
																								Validators: []validator.Bool{
																									speakeasy_boolvalidators.NotNull(),
																								},
																							},
																						},
																						Description: `Leading zeros validation`,
																						Validators: []validator.Object{
																							objectvalidator.ConflictsWith(path.Expressions{
																								path.MatchRelative().AtParent().AtName("one"),
																								path.MatchRelative().AtParent().AtName("two"),
																								path.MatchRelative().AtParent().AtName("three"),
																							}...),
																						},
																					},
																					"one": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"fact": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `The numeric value extracted from input; The amount of digits. Not Null; must be one of ["numeric-value", "total-length"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"numeric-value",
																										"total-length",
																									),
																								},
																							},
																							"operator": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Numeric comparison operator. Not Null; must be one of ["equal", "notEqual", "lessThan", "lessThanInclusive", "greaterThan", "greaterThanInclusive"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"equal",
																										"notEqual",
																										"lessThan",
																										"lessThanInclusive",
																										"greaterThan",
																										"greaterThanInclusive",
																									),
																								},
																							},
																							"params": schema.SingleNestedAttribute{
																								Computed: true,
																								Optional: true,
																								Attributes: map[string]schema.Attribute{
																									"error_message": schema.StringAttribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `Custom error message`,
																									},
																								},
																								Description: `Additional parameters for the condition`,
																							},
																							"value": schema.Float64Attribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Numeric value to compare against. Not Null`,
																								Validators: []validator.Float64{
																									speakeasy_float64validators.NotNull(),
																								},
																							},
																						},
																						Description: `Numeric value comparison`,
																						Validators: []validator.Object{
																							objectvalidator.ConflictsWith(path.Expressions{
																								path.MatchRelative().AtParent().AtName("two"),
																								path.MatchRelative().AtParent().AtName("three"),
																								path.MatchRelative().AtParent().AtName("four"),
																							}...),
																						},
																					},
																					"three": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"fact": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Count of decimal digits. Not Null; must be "decimal-digits-count"`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"decimal-digits-count",
																									),
																								},
																							},
																							"operator": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Decimal digit count comparison operator. Not Null; must be one of ["equal", "minDecimalDigits", "maxDecimalDigits"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"equal",
																										"minDecimalDigits",
																										"maxDecimalDigits",
																									),
																								},
																							},
																							"params": schema.SingleNestedAttribute{
																								Computed: true,
																								Optional: true,
																								Attributes: map[string]schema.Attribute{
																									"error_message": schema.StringAttribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `Custom error message`,
																									},
																								},
																								Description: `Additional parameters for the condition`,
																							},
																							"value": schema.Float64Attribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Expected number of decimal digits. Not Null`,
																								Validators: []validator.Float64{
																									speakeasy_float64validators.NotNull(),
																								},
																							},
																						},
																						Description: `Decimal digits count validation`,
																						Validators: []validator.Object{
																							objectvalidator.ConflictsWith(path.Expressions{
																								path.MatchRelative().AtParent().AtName("one"),
																								path.MatchRelative().AtParent().AtName("two"),
																								path.MatchRelative().AtParent().AtName("four"),
																							}...),
																						},
																					},
																					"two": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"fact": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Count of integer digits (excludes leading zeros unless allowed). Not Null; must be "integer-digits-count"`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"integer-digits-count",
																									),
																								},
																							},
																							"operator": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Digit count comparison operator. Not Null; must be one of ["equal", "exactlyNDigits", "minIntegerDigits", "maxIntegerDigits"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"equal",
																										"exactlyNDigits",
																										"minIntegerDigits",
																										"maxIntegerDigits",
																									),
																								},
																							},
																							"params": schema.SingleNestedAttribute{
																								Computed: true,
																								Optional: true,
																								Attributes: map[string]schema.Attribute{
																									"allow_leading_zeroes": schema.BoolAttribute{
																										Computed:    true,
																										Optional:    true,
																										Default:     booldefault.StaticBool(false),
																										Description: `Whether to count leading zeroes in digit count. Default: false`,
																									},
																									"error_message": schema.StringAttribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `Custom error message`,
																									},
																								},
																								Description: `Additional parameters for the condition`,
																							},
																							"value": schema.Float64Attribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Expected number of integer digits. Not Null`,
																								Validators: []validator.Float64{
																									speakeasy_float64validators.NotNull(),
																								},
																							},
																						},
																						Description: `Integer digits count validation`,
																						Validators: []validator.Object{
																							objectvalidator.ConflictsWith(path.Expressions{
																								path.MatchRelative().AtParent().AtName("one"),
																								path.MatchRelative().AtParent().AtName("three"),
																								path.MatchRelative().AtParent().AtName("four"),
																							}...),
																						},
																					},
																				},
																			},
																			Description: `Not Null`,
																			Validators: []validator.List{
																				speakeasy_listvalidators.NotNull(),
																			},
																		},
																	},
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("two"),
																			path.MatchRelative().AtParent().AtName("three"),
																		}...),
																	},
																},
																"three": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"not": schema.SingleNestedAttribute{
																			Computed: true,
																			Optional: true,
																			Attributes: map[string]schema.Attribute{
																				"four": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"fact": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Whether the input has leading zeros. Not Null; must be "has-leading-zeroes"`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"has-leading-zeroes",
																								),
																							},
																						},
																						"operator": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Leading zeros check operator. Not Null; must be one of ["equal", "notAllowed"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"equal",
																									"notAllowed",
																								),
																							},
																						},
																						"params": schema.SingleNestedAttribute{
																							Computed: true,
																							Optional: true,
																							Attributes: map[string]schema.Attribute{
																								"error_message": schema.StringAttribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `Custom error message`,
																								},
																							},
																							Description: `Additional parameters for the condition`,
																						},
																						"value": schema.BoolAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Whether leading zeros should be present or not. Not Null`,
																							Validators: []validator.Bool{
																								speakeasy_boolvalidators.NotNull(),
																							},
																						},
																					},
																					Description: `Leading zeros validation`,
																					Validators: []validator.Object{
																						objectvalidator.ConflictsWith(path.Expressions{
																							path.MatchRelative().AtParent().AtName("one"),
																							path.MatchRelative().AtParent().AtName("two"),
																							path.MatchRelative().AtParent().AtName("three"),
																						}...),
																					},
																				},
																				"one": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"fact": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `The numeric value extracted from input; The amount of digits. Not Null; must be one of ["numeric-value", "total-length"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"numeric-value",
																									"total-length",
																								),
																							},
																						},
																						"operator": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Numeric comparison operator. Not Null; must be one of ["equal", "notEqual", "lessThan", "lessThanInclusive", "greaterThan", "greaterThanInclusive"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"equal",
																									"notEqual",
																									"lessThan",
																									"lessThanInclusive",
																									"greaterThan",
																									"greaterThanInclusive",
																								),
																							},
																						},
																						"params": schema.SingleNestedAttribute{
																							Computed: true,
																							Optional: true,
																							Attributes: map[string]schema.Attribute{
																								"error_message": schema.StringAttribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `Custom error message`,
																								},
																							},
																							Description: `Additional parameters for the condition`,
																						},
																						"value": schema.Float64Attribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Numeric value to compare against. Not Null`,
																							Validators: []validator.Float64{
																								speakeasy_float64validators.NotNull(),
																							},
																						},
																					},
																					Description: `Numeric value comparison`,
																					Validators: []validator.Object{
																						objectvalidator.ConflictsWith(path.Expressions{
																							path.MatchRelative().AtParent().AtName("two"),
																							path.MatchRelative().AtParent().AtName("three"),
																							path.MatchRelative().AtParent().AtName("four"),
																						}...),
																					},
																				},
																				"three": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"fact": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Count of decimal digits. Not Null; must be "decimal-digits-count"`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"decimal-digits-count",
																								),
																							},
																						},
																						"operator": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Decimal digit count comparison operator. Not Null; must be one of ["equal", "minDecimalDigits", "maxDecimalDigits"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"equal",
																									"minDecimalDigits",
																									"maxDecimalDigits",
																								),
																							},
																						},
																						"params": schema.SingleNestedAttribute{
																							Computed: true,
																							Optional: true,
																							Attributes: map[string]schema.Attribute{
																								"error_message": schema.StringAttribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `Custom error message`,
																								},
																							},
																							Description: `Additional parameters for the condition`,
																						},
																						"value": schema.Float64Attribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Expected number of decimal digits. Not Null`,
																							Validators: []validator.Float64{
																								speakeasy_float64validators.NotNull(),
																							},
																						},
																					},
																					Description: `Decimal digits count validation`,
																					Validators: []validator.Object{
																						objectvalidator.ConflictsWith(path.Expressions{
																							path.MatchRelative().AtParent().AtName("one"),
																							path.MatchRelative().AtParent().AtName("two"),
																							path.MatchRelative().AtParent().AtName("four"),
																						}...),
																					},
																				},
																				"two": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"fact": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Count of integer digits (excludes leading zeros unless allowed). Not Null; must be "integer-digits-count"`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"integer-digits-count",
																								),
																							},
																						},
																						"operator": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Digit count comparison operator. Not Null; must be one of ["equal", "exactlyNDigits", "minIntegerDigits", "maxIntegerDigits"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"equal",
																									"exactlyNDigits",
																									"minIntegerDigits",
																									"maxIntegerDigits",
																								),
																							},
																						},
																						"params": schema.SingleNestedAttribute{
																							Computed: true,
																							Optional: true,
																							Attributes: map[string]schema.Attribute{
																								"allow_leading_zeroes": schema.BoolAttribute{
																									Computed:    true,
																									Optional:    true,
																									Default:     booldefault.StaticBool(false),
																									Description: `Whether to count leading zeroes in digit count. Default: false`,
																								},
																								"error_message": schema.StringAttribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `Custom error message`,
																								},
																							},
																							Description: `Additional parameters for the condition`,
																						},
																						"value": schema.Float64Attribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Expected number of integer digits. Not Null`,
																							Validators: []validator.Float64{
																								speakeasy_float64validators.NotNull(),
																							},
																						},
																					},
																					Description: `Integer digits count validation`,
																					Validators: []validator.Object{
																						objectvalidator.ConflictsWith(path.Expressions{
																							path.MatchRelative().AtParent().AtName("one"),
																							path.MatchRelative().AtParent().AtName("three"),
																							path.MatchRelative().AtParent().AtName("four"),
																						}...),
																					},
																				},
																			},
																			Description: `Fact-based condition for numeric validation. Not Null`,
																			Validators: []validator.Object{
																				speakeasy_objectvalidators.NotNull(),
																			},
																		},
																	},
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("one"),
																			path.MatchRelative().AtParent().AtName("two"),
																		}...),
																	},
																},
																"two": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"any": schema.ListNestedAttribute{
																			Computed: true,
																			Optional: true,
																			NestedObject: schema.NestedAttributeObject{
																				Validators: []validator.Object{
																					speakeasy_objectvalidators.NotNull(),
																				},
																				Attributes: map[string]schema.Attribute{
																					"four": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"fact": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Whether the input has leading zeros. Not Null; must be "has-leading-zeroes"`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"has-leading-zeroes",
																									),
																								},
																							},
																							"operator": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Leading zeros check operator. Not Null; must be one of ["equal", "notAllowed"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"equal",
																										"notAllowed",
																									),
																								},
																							},
																							"params": schema.SingleNestedAttribute{
																								Computed: true,
																								Optional: true,
																								Attributes: map[string]schema.Attribute{
																									"error_message": schema.StringAttribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `Custom error message`,
																									},
																								},
																								Description: `Additional parameters for the condition`,
																							},
																							"value": schema.BoolAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Whether leading zeros should be present or not. Not Null`,
																								Validators: []validator.Bool{
																									speakeasy_boolvalidators.NotNull(),
																								},
																							},
																						},
																						Description: `Leading zeros validation`,
																						Validators: []validator.Object{
																							objectvalidator.ConflictsWith(path.Expressions{
																								path.MatchRelative().AtParent().AtName("one"),
																								path.MatchRelative().AtParent().AtName("two"),
																								path.MatchRelative().AtParent().AtName("three"),
																							}...),
																						},
																					},
																					"one": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"fact": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `The numeric value extracted from input; The amount of digits. Not Null; must be one of ["numeric-value", "total-length"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"numeric-value",
																										"total-length",
																									),
																								},
																							},
																							"operator": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Numeric comparison operator. Not Null; must be one of ["equal", "notEqual", "lessThan", "lessThanInclusive", "greaterThan", "greaterThanInclusive"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"equal",
																										"notEqual",
																										"lessThan",
																										"lessThanInclusive",
																										"greaterThan",
																										"greaterThanInclusive",
																									),
																								},
																							},
																							"params": schema.SingleNestedAttribute{
																								Computed: true,
																								Optional: true,
																								Attributes: map[string]schema.Attribute{
																									"error_message": schema.StringAttribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `Custom error message`,
																									},
																								},
																								Description: `Additional parameters for the condition`,
																							},
																							"value": schema.Float64Attribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Numeric value to compare against. Not Null`,
																								Validators: []validator.Float64{
																									speakeasy_float64validators.NotNull(),
																								},
																							},
																						},
																						Description: `Numeric value comparison`,
																						Validators: []validator.Object{
																							objectvalidator.ConflictsWith(path.Expressions{
																								path.MatchRelative().AtParent().AtName("two"),
																								path.MatchRelative().AtParent().AtName("three"),
																								path.MatchRelative().AtParent().AtName("four"),
																							}...),
																						},
																					},
																					"three": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"fact": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Count of decimal digits. Not Null; must be "decimal-digits-count"`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"decimal-digits-count",
																									),
																								},
																							},
																							"operator": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Decimal digit count comparison operator. Not Null; must be one of ["equal", "minDecimalDigits", "maxDecimalDigits"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"equal",
																										"minDecimalDigits",
																										"maxDecimalDigits",
																									),
																								},
																							},
																							"params": schema.SingleNestedAttribute{
																								Computed: true,
																								Optional: true,
																								Attributes: map[string]schema.Attribute{
																									"error_message": schema.StringAttribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `Custom error message`,
																									},
																								},
																								Description: `Additional parameters for the condition`,
																							},
																							"value": schema.Float64Attribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Expected number of decimal digits. Not Null`,
																								Validators: []validator.Float64{
																									speakeasy_float64validators.NotNull(),
																								},
																							},
																						},
																						Description: `Decimal digits count validation`,
																						Validators: []validator.Object{
																							objectvalidator.ConflictsWith(path.Expressions{
																								path.MatchRelative().AtParent().AtName("one"),
																								path.MatchRelative().AtParent().AtName("two"),
																								path.MatchRelative().AtParent().AtName("four"),
																							}...),
																						},
																					},
																					"two": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"fact": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Count of integer digits (excludes leading zeros unless allowed). Not Null; must be "integer-digits-count"`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"integer-digits-count",
																									),
																								},
																							},
																							"operator": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Digit count comparison operator. Not Null; must be one of ["equal", "exactlyNDigits", "minIntegerDigits", "maxIntegerDigits"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"equal",
																										"exactlyNDigits",
																										"minIntegerDigits",
																										"maxIntegerDigits",
																									),
																								},
																							},
																							"params": schema.SingleNestedAttribute{
																								Computed: true,
																								Optional: true,
																								Attributes: map[string]schema.Attribute{
																									"allow_leading_zeroes": schema.BoolAttribute{
																										Computed:    true,
																										Optional:    true,
																										Default:     booldefault.StaticBool(false),
																										Description: `Whether to count leading zeroes in digit count. Default: false`,
																									},
																									"error_message": schema.StringAttribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `Custom error message`,
																									},
																								},
																								Description: `Additional parameters for the condition`,
																							},
																							"value": schema.Float64Attribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Expected number of integer digits. Not Null`,
																								Validators: []validator.Float64{
																									speakeasy_float64validators.NotNull(),
																								},
																							},
																						},
																						Description: `Integer digits count validation`,
																						Validators: []validator.Object{
																							objectvalidator.ConflictsWith(path.Expressions{
																								path.MatchRelative().AtParent().AtName("one"),
																								path.MatchRelative().AtParent().AtName("three"),
																								path.MatchRelative().AtParent().AtName("four"),
																							}...),
																						},
																					},
																				},
																			},
																			Description: `Not Null`,
																			Validators: []validator.List{
																				speakeasy_listvalidators.NotNull(),
																			},
																		},
																	},
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("one"),
																			path.MatchRelative().AtParent().AtName("three"),
																		}...),
																	},
																},
															},
															Description: `Nested condition with logical operators (level 2 only)`,
															Validators: []validator.Object{
																objectvalidator.ConflictsWith(path.Expressions{
																	path.MatchRelative().AtParent().AtName("numeric_fact_condition"),
																}...),
															},
														},
													},
												},
												Description: `Not Null`,
												Validators: []validator.List{
													speakeasy_listvalidators.NotNull(),
												},
											},
										},
										Description: `All conditions must be true (AND logic)`,
										Validators: []validator.Object{
											objectvalidator.ConflictsWith(path.Expressions{
												path.MatchRelative().AtParent().AtName("two"),
												path.MatchRelative().AtParent().AtName("three"),
											}...),
										},
									},
									"three": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"not": schema.SingleNestedAttribute{
												Computed: true,
												Optional: true,
												Attributes: map[string]schema.Attribute{
													"numeric_fact_condition": schema.SingleNestedAttribute{
														Computed: true,
														Optional: true,
														Attributes: map[string]schema.Attribute{
															"four": schema.SingleNestedAttribute{
																Computed: true,
																Optional: true,
																Attributes: map[string]schema.Attribute{
																	"fact": schema.StringAttribute{
																		Computed:    true,
																		Optional:    true,
																		Description: `Whether the input has leading zeros. Not Null; must be "has-leading-zeroes"`,
																		Validators: []validator.String{
																			speakeasy_stringvalidators.NotNull(),
																			stringvalidator.OneOf(
																				"has-leading-zeroes",
																			),
																		},
																	},
																	"operator": schema.StringAttribute{
																		Computed:    true,
																		Optional:    true,
																		Description: `Leading zeros check operator. Not Null; must be one of ["equal", "notAllowed"]`,
																		Validators: []validator.String{
																			speakeasy_stringvalidators.NotNull(),
																			stringvalidator.OneOf(
																				"equal",
																				"notAllowed",
																			),
																		},
																	},
																	"params": schema.SingleNestedAttribute{
																		Computed: true,
																		Optional: true,
																		Attributes: map[string]schema.Attribute{
																			"error_message": schema.StringAttribute{
																				Computed:    true,
																				Optional:    true,
																				Description: `Custom error message`,
																			},
																		},
																		Description: `Additional parameters for the condition`,
																	},
																	"value": schema.BoolAttribute{
																		Computed:    true,
																		Optional:    true,
																		Description: `Whether leading zeros should be present or not. Not Null`,
																		Validators: []validator.Bool{
																			speakeasy_boolvalidators.NotNull(),
																		},
																	},
																},
																Description: `Leading zeros validation`,
																Validators: []validator.Object{
																	objectvalidator.ConflictsWith(path.Expressions{
																		path.MatchRelative().AtParent().AtName("one"),
																		path.MatchRelative().AtParent().AtName("two"),
																		path.MatchRelative().AtParent().AtName("three"),
																	}...),
																},
															},
															"one": schema.SingleNestedAttribute{
																Computed: true,
																Optional: true,
																Attributes: map[string]schema.Attribute{
																	"fact": schema.StringAttribute{
																		Computed:    true,
																		Optional:    true,
																		Description: `The numeric value extracted from input; The amount of digits. Not Null; must be one of ["numeric-value", "total-length"]`,
																		Validators: []validator.String{
																			speakeasy_stringvalidators.NotNull(),
																			stringvalidator.OneOf(
																				"numeric-value",
																				"total-length",
																			),
																		},
																	},
																	"operator": schema.StringAttribute{
																		Computed:    true,
																		Optional:    true,
																		Description: `Numeric comparison operator. Not Null; must be one of ["equal", "notEqual", "lessThan", "lessThanInclusive", "greaterThan", "greaterThanInclusive"]`,
																		Validators: []validator.String{
																			speakeasy_stringvalidators.NotNull(),
																			stringvalidator.OneOf(
																				"equal",
																				"notEqual",
																				"lessThan",
																				"lessThanInclusive",
																				"greaterThan",
																				"greaterThanInclusive",
																			),
																		},
																	},
																	"params": schema.SingleNestedAttribute{
																		Computed: true,
																		Optional: true,
																		Attributes: map[string]schema.Attribute{
																			"error_message": schema.StringAttribute{
																				Computed:    true,
																				Optional:    true,
																				Description: `Custom error message`,
																			},
																		},
																		Description: `Additional parameters for the condition`,
																	},
																	"value": schema.Float64Attribute{
																		Computed:    true,
																		Optional:    true,
																		Description: `Numeric value to compare against. Not Null`,
																		Validators: []validator.Float64{
																			speakeasy_float64validators.NotNull(),
																		},
																	},
																},
																Description: `Numeric value comparison`,
																Validators: []validator.Object{
																	objectvalidator.ConflictsWith(path.Expressions{
																		path.MatchRelative().AtParent().AtName("two"),
																		path.MatchRelative().AtParent().AtName("three"),
																		path.MatchRelative().AtParent().AtName("four"),
																	}...),
																},
															},
															"three": schema.SingleNestedAttribute{
																Computed: true,
																Optional: true,
																Attributes: map[string]schema.Attribute{
																	"fact": schema.StringAttribute{
																		Computed:    true,
																		Optional:    true,
																		Description: `Count of decimal digits. Not Null; must be "decimal-digits-count"`,
																		Validators: []validator.String{
																			speakeasy_stringvalidators.NotNull(),
																			stringvalidator.OneOf(
																				"decimal-digits-count",
																			),
																		},
																	},
																	"operator": schema.StringAttribute{
																		Computed:    true,
																		Optional:    true,
																		Description: `Decimal digit count comparison operator. Not Null; must be one of ["equal", "minDecimalDigits", "maxDecimalDigits"]`,
																		Validators: []validator.String{
																			speakeasy_stringvalidators.NotNull(),
																			stringvalidator.OneOf(
																				"equal",
																				"minDecimalDigits",
																				"maxDecimalDigits",
																			),
																		},
																	},
																	"params": schema.SingleNestedAttribute{
																		Computed: true,
																		Optional: true,
																		Attributes: map[string]schema.Attribute{
																			"error_message": schema.StringAttribute{
																				Computed:    true,
																				Optional:    true,
																				Description: `Custom error message`,
																			},
																		},
																		Description: `Additional parameters for the condition`,
																	},
																	"value": schema.Float64Attribute{
																		Computed:    true,
																		Optional:    true,
																		Description: `Expected number of decimal digits. Not Null`,
																		Validators: []validator.Float64{
																			speakeasy_float64validators.NotNull(),
																		},
																	},
																},
																Description: `Decimal digits count validation`,
																Validators: []validator.Object{
																	objectvalidator.ConflictsWith(path.Expressions{
																		path.MatchRelative().AtParent().AtName("one"),
																		path.MatchRelative().AtParent().AtName("two"),
																		path.MatchRelative().AtParent().AtName("four"),
																	}...),
																},
															},
															"two": schema.SingleNestedAttribute{
																Computed: true,
																Optional: true,
																Attributes: map[string]schema.Attribute{
																	"fact": schema.StringAttribute{
																		Computed:    true,
																		Optional:    true,
																		Description: `Count of integer digits (excludes leading zeros unless allowed). Not Null; must be "integer-digits-count"`,
																		Validators: []validator.String{
																			speakeasy_stringvalidators.NotNull(),
																			stringvalidator.OneOf(
																				"integer-digits-count",
																			),
																		},
																	},
																	"operator": schema.StringAttribute{
																		Computed:    true,
																		Optional:    true,
																		Description: `Digit count comparison operator. Not Null; must be one of ["equal", "exactlyNDigits", "minIntegerDigits", "maxIntegerDigits"]`,
																		Validators: []validator.String{
																			speakeasy_stringvalidators.NotNull(),
																			stringvalidator.OneOf(
																				"equal",
																				"exactlyNDigits",
																				"minIntegerDigits",
																				"maxIntegerDigits",
																			),
																		},
																	},
																	"params": schema.SingleNestedAttribute{
																		Computed: true,
																		Optional: true,
																		Attributes: map[string]schema.Attribute{
																			"allow_leading_zeroes": schema.BoolAttribute{
																				Computed:    true,
																				Optional:    true,
																				Default:     booldefault.StaticBool(false),
																				Description: `Whether to count leading zeroes in digit count. Default: false`,
																			},
																			"error_message": schema.StringAttribute{
																				Computed:    true,
																				Optional:    true,
																				Description: `Custom error message`,
																			},
																		},
																		Description: `Additional parameters for the condition`,
																	},
																	"value": schema.Float64Attribute{
																		Computed:    true,
																		Optional:    true,
																		Description: `Expected number of integer digits. Not Null`,
																		Validators: []validator.Float64{
																			speakeasy_float64validators.NotNull(),
																		},
																	},
																},
																Description: `Integer digits count validation`,
																Validators: []validator.Object{
																	objectvalidator.ConflictsWith(path.Expressions{
																		path.MatchRelative().AtParent().AtName("one"),
																		path.MatchRelative().AtParent().AtName("three"),
																		path.MatchRelative().AtParent().AtName("four"),
																	}...),
																},
															},
														},
														Description: `Fact-based condition for numeric validation`,
														Validators: []validator.Object{
															objectvalidator.ConflictsWith(path.Expressions{
																path.MatchRelative().AtParent().AtName("numeric_nested_condition"),
															}...),
														},
													},
													"numeric_nested_condition": schema.SingleNestedAttribute{
														Computed: true,
														Optional: true,
														Attributes: map[string]schema.Attribute{
															"one": schema.SingleNestedAttribute{
																Computed: true,
																Optional: true,
																Attributes: map[string]schema.Attribute{
																	"all": schema.ListNestedAttribute{
																		Computed: true,
																		Optional: true,
																		NestedObject: schema.NestedAttributeObject{
																			Validators: []validator.Object{
																				speakeasy_objectvalidators.NotNull(),
																			},
																			Attributes: map[string]schema.Attribute{
																				"four": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"fact": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Whether the input has leading zeros. Not Null; must be "has-leading-zeroes"`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"has-leading-zeroes",
																								),
																							},
																						},
																						"operator": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Leading zeros check operator. Not Null; must be one of ["equal", "notAllowed"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"equal",
																									"notAllowed",
																								),
																							},
																						},
																						"params": schema.SingleNestedAttribute{
																							Computed: true,
																							Optional: true,
																							Attributes: map[string]schema.Attribute{
																								"error_message": schema.StringAttribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `Custom error message`,
																								},
																							},
																							Description: `Additional parameters for the condition`,
																						},
																						"value": schema.BoolAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Whether leading zeros should be present or not. Not Null`,
																							Validators: []validator.Bool{
																								speakeasy_boolvalidators.NotNull(),
																							},
																						},
																					},
																					Description: `Leading zeros validation`,
																					Validators: []validator.Object{
																						objectvalidator.ConflictsWith(path.Expressions{
																							path.MatchRelative().AtParent().AtName("one"),
																							path.MatchRelative().AtParent().AtName("two"),
																							path.MatchRelative().AtParent().AtName("three"),
																						}...),
																					},
																				},
																				"one": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"fact": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `The numeric value extracted from input; The amount of digits. Not Null; must be one of ["numeric-value", "total-length"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"numeric-value",
																									"total-length",
																								),
																							},
																						},
																						"operator": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Numeric comparison operator. Not Null; must be one of ["equal", "notEqual", "lessThan", "lessThanInclusive", "greaterThan", "greaterThanInclusive"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"equal",
																									"notEqual",
																									"lessThan",
																									"lessThanInclusive",
																									"greaterThan",
																									"greaterThanInclusive",
																								),
																							},
																						},
																						"params": schema.SingleNestedAttribute{
																							Computed: true,
																							Optional: true,
																							Attributes: map[string]schema.Attribute{
																								"error_message": schema.StringAttribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `Custom error message`,
																								},
																							},
																							Description: `Additional parameters for the condition`,
																						},
																						"value": schema.Float64Attribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Numeric value to compare against. Not Null`,
																							Validators: []validator.Float64{
																								speakeasy_float64validators.NotNull(),
																							},
																						},
																					},
																					Description: `Numeric value comparison`,
																					Validators: []validator.Object{
																						objectvalidator.ConflictsWith(path.Expressions{
																							path.MatchRelative().AtParent().AtName("two"),
																							path.MatchRelative().AtParent().AtName("three"),
																							path.MatchRelative().AtParent().AtName("four"),
																						}...),
																					},
																				},
																				"three": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"fact": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Count of decimal digits. Not Null; must be "decimal-digits-count"`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"decimal-digits-count",
																								),
																							},
																						},
																						"operator": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Decimal digit count comparison operator. Not Null; must be one of ["equal", "minDecimalDigits", "maxDecimalDigits"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"equal",
																									"minDecimalDigits",
																									"maxDecimalDigits",
																								),
																							},
																						},
																						"params": schema.SingleNestedAttribute{
																							Computed: true,
																							Optional: true,
																							Attributes: map[string]schema.Attribute{
																								"error_message": schema.StringAttribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `Custom error message`,
																								},
																							},
																							Description: `Additional parameters for the condition`,
																						},
																						"value": schema.Float64Attribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Expected number of decimal digits. Not Null`,
																							Validators: []validator.Float64{
																								speakeasy_float64validators.NotNull(),
																							},
																						},
																					},
																					Description: `Decimal digits count validation`,
																					Validators: []validator.Object{
																						objectvalidator.ConflictsWith(path.Expressions{
																							path.MatchRelative().AtParent().AtName("one"),
																							path.MatchRelative().AtParent().AtName("two"),
																							path.MatchRelative().AtParent().AtName("four"),
																						}...),
																					},
																				},
																				"two": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"fact": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Count of integer digits (excludes leading zeros unless allowed). Not Null; must be "integer-digits-count"`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"integer-digits-count",
																								),
																							},
																						},
																						"operator": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Digit count comparison operator. Not Null; must be one of ["equal", "exactlyNDigits", "minIntegerDigits", "maxIntegerDigits"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"equal",
																									"exactlyNDigits",
																									"minIntegerDigits",
																									"maxIntegerDigits",
																								),
																							},
																						},
																						"params": schema.SingleNestedAttribute{
																							Computed: true,
																							Optional: true,
																							Attributes: map[string]schema.Attribute{
																								"allow_leading_zeroes": schema.BoolAttribute{
																									Computed:    true,
																									Optional:    true,
																									Default:     booldefault.StaticBool(false),
																									Description: `Whether to count leading zeroes in digit count. Default: false`,
																								},
																								"error_message": schema.StringAttribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `Custom error message`,
																								},
																							},
																							Description: `Additional parameters for the condition`,
																						},
																						"value": schema.Float64Attribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Expected number of integer digits. Not Null`,
																							Validators: []validator.Float64{
																								speakeasy_float64validators.NotNull(),
																							},
																						},
																					},
																					Description: `Integer digits count validation`,
																					Validators: []validator.Object{
																						objectvalidator.ConflictsWith(path.Expressions{
																							path.MatchRelative().AtParent().AtName("one"),
																							path.MatchRelative().AtParent().AtName("three"),
																							path.MatchRelative().AtParent().AtName("four"),
																						}...),
																					},
																				},
																			},
																		},
																		Description: `Not Null`,
																		Validators: []validator.List{
																			speakeasy_listvalidators.NotNull(),
																		},
																	},
																},
																Validators: []validator.Object{
																	objectvalidator.ConflictsWith(path.Expressions{
																		path.MatchRelative().AtParent().AtName("two"),
																		path.MatchRelative().AtParent().AtName("three"),
																	}...),
																},
															},
															"three": schema.SingleNestedAttribute{
																Computed: true,
																Optional: true,
																Attributes: map[string]schema.Attribute{
																	"not": schema.SingleNestedAttribute{
																		Computed: true,
																		Optional: true,
																		Attributes: map[string]schema.Attribute{
																			"four": schema.SingleNestedAttribute{
																				Computed: true,
																				Optional: true,
																				Attributes: map[string]schema.Attribute{
																					"fact": schema.StringAttribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `Whether the input has leading zeros. Not Null; must be "has-leading-zeroes"`,
																						Validators: []validator.String{
																							speakeasy_stringvalidators.NotNull(),
																							stringvalidator.OneOf(
																								"has-leading-zeroes",
																							),
																						},
																					},
																					"operator": schema.StringAttribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `Leading zeros check operator. Not Null; must be one of ["equal", "notAllowed"]`,
																						Validators: []validator.String{
																							speakeasy_stringvalidators.NotNull(),
																							stringvalidator.OneOf(
																								"equal",
																								"notAllowed",
																							),
																						},
																					},
																					"params": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"error_message": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Custom error message`,
																							},
																						},
																						Description: `Additional parameters for the condition`,
																					},
																					"value": schema.BoolAttribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `Whether leading zeros should be present or not. Not Null`,
																						Validators: []validator.Bool{
																							speakeasy_boolvalidators.NotNull(),
																						},
																					},
																				},
																				Description: `Leading zeros validation`,
																				Validators: []validator.Object{
																					objectvalidator.ConflictsWith(path.Expressions{
																						path.MatchRelative().AtParent().AtName("one"),
																						path.MatchRelative().AtParent().AtName("two"),
																						path.MatchRelative().AtParent().AtName("three"),
																					}...),
																				},
																			},
																			"one": schema.SingleNestedAttribute{
																				Computed: true,
																				Optional: true,
																				Attributes: map[string]schema.Attribute{
																					"fact": schema.StringAttribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `The numeric value extracted from input; The amount of digits. Not Null; must be one of ["numeric-value", "total-length"]`,
																						Validators: []validator.String{
																							speakeasy_stringvalidators.NotNull(),
																							stringvalidator.OneOf(
																								"numeric-value",
																								"total-length",
																							),
																						},
																					},
																					"operator": schema.StringAttribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `Numeric comparison operator. Not Null; must be one of ["equal", "notEqual", "lessThan", "lessThanInclusive", "greaterThan", "greaterThanInclusive"]`,
																						Validators: []validator.String{
																							speakeasy_stringvalidators.NotNull(),
																							stringvalidator.OneOf(
																								"equal",
																								"notEqual",
																								"lessThan",
																								"lessThanInclusive",
																								"greaterThan",
																								"greaterThanInclusive",
																							),
																						},
																					},
																					"params": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"error_message": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Custom error message`,
																							},
																						},
																						Description: `Additional parameters for the condition`,
																					},
																					"value": schema.Float64Attribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `Numeric value to compare against. Not Null`,
																						Validators: []validator.Float64{
																							speakeasy_float64validators.NotNull(),
																						},
																					},
																				},
																				Description: `Numeric value comparison`,
																				Validators: []validator.Object{
																					objectvalidator.ConflictsWith(path.Expressions{
																						path.MatchRelative().AtParent().AtName("two"),
																						path.MatchRelative().AtParent().AtName("three"),
																						path.MatchRelative().AtParent().AtName("four"),
																					}...),
																				},
																			},
																			"three": schema.SingleNestedAttribute{
																				Computed: true,
																				Optional: true,
																				Attributes: map[string]schema.Attribute{
																					"fact": schema.StringAttribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `Count of decimal digits. Not Null; must be "decimal-digits-count"`,
																						Validators: []validator.String{
																							speakeasy_stringvalidators.NotNull(),
																							stringvalidator.OneOf(
																								"decimal-digits-count",
																							),
																						},
																					},
																					"operator": schema.StringAttribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `Decimal digit count comparison operator. Not Null; must be one of ["equal", "minDecimalDigits", "maxDecimalDigits"]`,
																						Validators: []validator.String{
																							speakeasy_stringvalidators.NotNull(),
																							stringvalidator.OneOf(
																								"equal",
																								"minDecimalDigits",
																								"maxDecimalDigits",
																							),
																						},
																					},
																					"params": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"error_message": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Custom error message`,
																							},
																						},
																						Description: `Additional parameters for the condition`,
																					},
																					"value": schema.Float64Attribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `Expected number of decimal digits. Not Null`,
																						Validators: []validator.Float64{
																							speakeasy_float64validators.NotNull(),
																						},
																					},
																				},
																				Description: `Decimal digits count validation`,
																				Validators: []validator.Object{
																					objectvalidator.ConflictsWith(path.Expressions{
																						path.MatchRelative().AtParent().AtName("one"),
																						path.MatchRelative().AtParent().AtName("two"),
																						path.MatchRelative().AtParent().AtName("four"),
																					}...),
																				},
																			},
																			"two": schema.SingleNestedAttribute{
																				Computed: true,
																				Optional: true,
																				Attributes: map[string]schema.Attribute{
																					"fact": schema.StringAttribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `Count of integer digits (excludes leading zeros unless allowed). Not Null; must be "integer-digits-count"`,
																						Validators: []validator.String{
																							speakeasy_stringvalidators.NotNull(),
																							stringvalidator.OneOf(
																								"integer-digits-count",
																							),
																						},
																					},
																					"operator": schema.StringAttribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `Digit count comparison operator. Not Null; must be one of ["equal", "exactlyNDigits", "minIntegerDigits", "maxIntegerDigits"]`,
																						Validators: []validator.String{
																							speakeasy_stringvalidators.NotNull(),
																							stringvalidator.OneOf(
																								"equal",
																								"exactlyNDigits",
																								"minIntegerDigits",
																								"maxIntegerDigits",
																							),
																						},
																					},
																					"params": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"allow_leading_zeroes": schema.BoolAttribute{
																								Computed:    true,
																								Optional:    true,
																								Default:     booldefault.StaticBool(false),
																								Description: `Whether to count leading zeroes in digit count. Default: false`,
																							},
																							"error_message": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Custom error message`,
																							},
																						},
																						Description: `Additional parameters for the condition`,
																					},
																					"value": schema.Float64Attribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `Expected number of integer digits. Not Null`,
																						Validators: []validator.Float64{
																							speakeasy_float64validators.NotNull(),
																						},
																					},
																				},
																				Description: `Integer digits count validation`,
																				Validators: []validator.Object{
																					objectvalidator.ConflictsWith(path.Expressions{
																						path.MatchRelative().AtParent().AtName("one"),
																						path.MatchRelative().AtParent().AtName("three"),
																						path.MatchRelative().AtParent().AtName("four"),
																					}...),
																				},
																			},
																		},
																		Description: `Fact-based condition for numeric validation. Not Null`,
																		Validators: []validator.Object{
																			speakeasy_objectvalidators.NotNull(),
																		},
																	},
																},
																Validators: []validator.Object{
																	objectvalidator.ConflictsWith(path.Expressions{
																		path.MatchRelative().AtParent().AtName("one"),
																		path.MatchRelative().AtParent().AtName("two"),
																	}...),
																},
															},
															"two": schema.SingleNestedAttribute{
																Computed: true,
																Optional: true,
																Attributes: map[string]schema.Attribute{
																	"any": schema.ListNestedAttribute{
																		Computed: true,
																		Optional: true,
																		NestedObject: schema.NestedAttributeObject{
																			Validators: []validator.Object{
																				speakeasy_objectvalidators.NotNull(),
																			},
																			Attributes: map[string]schema.Attribute{
																				"four": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"fact": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Whether the input has leading zeros. Not Null; must be "has-leading-zeroes"`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"has-leading-zeroes",
																								),
																							},
																						},
																						"operator": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Leading zeros check operator. Not Null; must be one of ["equal", "notAllowed"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"equal",
																									"notAllowed",
																								),
																							},
																						},
																						"params": schema.SingleNestedAttribute{
																							Computed: true,
																							Optional: true,
																							Attributes: map[string]schema.Attribute{
																								"error_message": schema.StringAttribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `Custom error message`,
																								},
																							},
																							Description: `Additional parameters for the condition`,
																						},
																						"value": schema.BoolAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Whether leading zeros should be present or not. Not Null`,
																							Validators: []validator.Bool{
																								speakeasy_boolvalidators.NotNull(),
																							},
																						},
																					},
																					Description: `Leading zeros validation`,
																					Validators: []validator.Object{
																						objectvalidator.ConflictsWith(path.Expressions{
																							path.MatchRelative().AtParent().AtName("one"),
																							path.MatchRelative().AtParent().AtName("two"),
																							path.MatchRelative().AtParent().AtName("three"),
																						}...),
																					},
																				},
																				"one": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"fact": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `The numeric value extracted from input; The amount of digits. Not Null; must be one of ["numeric-value", "total-length"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"numeric-value",
																									"total-length",
																								),
																							},
																						},
																						"operator": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Numeric comparison operator. Not Null; must be one of ["equal", "notEqual", "lessThan", "lessThanInclusive", "greaterThan", "greaterThanInclusive"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"equal",
																									"notEqual",
																									"lessThan",
																									"lessThanInclusive",
																									"greaterThan",
																									"greaterThanInclusive",
																								),
																							},
																						},
																						"params": schema.SingleNestedAttribute{
																							Computed: true,
																							Optional: true,
																							Attributes: map[string]schema.Attribute{
																								"error_message": schema.StringAttribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `Custom error message`,
																								},
																							},
																							Description: `Additional parameters for the condition`,
																						},
																						"value": schema.Float64Attribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Numeric value to compare against. Not Null`,
																							Validators: []validator.Float64{
																								speakeasy_float64validators.NotNull(),
																							},
																						},
																					},
																					Description: `Numeric value comparison`,
																					Validators: []validator.Object{
																						objectvalidator.ConflictsWith(path.Expressions{
																							path.MatchRelative().AtParent().AtName("two"),
																							path.MatchRelative().AtParent().AtName("three"),
																							path.MatchRelative().AtParent().AtName("four"),
																						}...),
																					},
																				},
																				"three": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"fact": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Count of decimal digits. Not Null; must be "decimal-digits-count"`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"decimal-digits-count",
																								),
																							},
																						},
																						"operator": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Decimal digit count comparison operator. Not Null; must be one of ["equal", "minDecimalDigits", "maxDecimalDigits"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"equal",
																									"minDecimalDigits",
																									"maxDecimalDigits",
																								),
																							},
																						},
																						"params": schema.SingleNestedAttribute{
																							Computed: true,
																							Optional: true,
																							Attributes: map[string]schema.Attribute{
																								"error_message": schema.StringAttribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `Custom error message`,
																								},
																							},
																							Description: `Additional parameters for the condition`,
																						},
																						"value": schema.Float64Attribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Expected number of decimal digits. Not Null`,
																							Validators: []validator.Float64{
																								speakeasy_float64validators.NotNull(),
																							},
																						},
																					},
																					Description: `Decimal digits count validation`,
																					Validators: []validator.Object{
																						objectvalidator.ConflictsWith(path.Expressions{
																							path.MatchRelative().AtParent().AtName("one"),
																							path.MatchRelative().AtParent().AtName("two"),
																							path.MatchRelative().AtParent().AtName("four"),
																						}...),
																					},
																				},
																				"two": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"fact": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Count of integer digits (excludes leading zeros unless allowed). Not Null; must be "integer-digits-count"`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"integer-digits-count",
																								),
																							},
																						},
																						"operator": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Digit count comparison operator. Not Null; must be one of ["equal", "exactlyNDigits", "minIntegerDigits", "maxIntegerDigits"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"equal",
																									"exactlyNDigits",
																									"minIntegerDigits",
																									"maxIntegerDigits",
																								),
																							},
																						},
																						"params": schema.SingleNestedAttribute{
																							Computed: true,
																							Optional: true,
																							Attributes: map[string]schema.Attribute{
																								"allow_leading_zeroes": schema.BoolAttribute{
																									Computed:    true,
																									Optional:    true,
																									Default:     booldefault.StaticBool(false),
																									Description: `Whether to count leading zeroes in digit count. Default: false`,
																								},
																								"error_message": schema.StringAttribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `Custom error message`,
																								},
																							},
																							Description: `Additional parameters for the condition`,
																						},
																						"value": schema.Float64Attribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Expected number of integer digits. Not Null`,
																							Validators: []validator.Float64{
																								speakeasy_float64validators.NotNull(),
																							},
																						},
																					},
																					Description: `Integer digits count validation`,
																					Validators: []validator.Object{
																						objectvalidator.ConflictsWith(path.Expressions{
																							path.MatchRelative().AtParent().AtName("one"),
																							path.MatchRelative().AtParent().AtName("three"),
																							path.MatchRelative().AtParent().AtName("four"),
																						}...),
																					},
																				},
																			},
																		},
																		Description: `Not Null`,
																		Validators: []validator.List{
																			speakeasy_listvalidators.NotNull(),
																		},
																	},
																},
																Validators: []validator.Object{
																	objectvalidator.ConflictsWith(path.Expressions{
																		path.MatchRelative().AtParent().AtName("one"),
																		path.MatchRelative().AtParent().AtName("three"),
																	}...),
																},
															},
														},
														Description: `Nested condition with logical operators (level 2 only)`,
														Validators: []validator.Object{
															objectvalidator.ConflictsWith(path.Expressions{
																path.MatchRelative().AtParent().AtName("numeric_fact_condition"),
															}...),
														},
													},
												},
												Description: `Not Null`,
												Validators: []validator.Object{
													speakeasy_objectvalidators.NotNull(),
												},
											},
										},
										Description: `NOT condition (negation)`,
										Validators: []validator.Object{
											objectvalidator.ConflictsWith(path.Expressions{
												path.MatchRelative().AtParent().AtName("one"),
												path.MatchRelative().AtParent().AtName("two"),
											}...),
										},
									},
									"two": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"any": schema.ListNestedAttribute{
												Computed: true,
												Optional: true,
												NestedObject: schema.NestedAttributeObject{
													Validators: []validator.Object{
														speakeasy_objectvalidators.NotNull(),
													},
													Attributes: map[string]schema.Attribute{
														"numeric_fact_condition": schema.SingleNestedAttribute{
															Computed: true,
															Optional: true,
															Attributes: map[string]schema.Attribute{
																"four": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"fact": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Whether the input has leading zeros. Not Null; must be "has-leading-zeroes"`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																				stringvalidator.OneOf(
																					"has-leading-zeroes",
																				),
																			},
																		},
																		"operator": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Leading zeros check operator. Not Null; must be one of ["equal", "notAllowed"]`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																				stringvalidator.OneOf(
																					"equal",
																					"notAllowed",
																				),
																			},
																		},
																		"params": schema.SingleNestedAttribute{
																			Computed: true,
																			Optional: true,
																			Attributes: map[string]schema.Attribute{
																				"error_message": schema.StringAttribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `Custom error message`,
																				},
																			},
																			Description: `Additional parameters for the condition`,
																		},
																		"value": schema.BoolAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Whether leading zeros should be present or not. Not Null`,
																			Validators: []validator.Bool{
																				speakeasy_boolvalidators.NotNull(),
																			},
																		},
																	},
																	Description: `Leading zeros validation`,
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("one"),
																			path.MatchRelative().AtParent().AtName("two"),
																			path.MatchRelative().AtParent().AtName("three"),
																		}...),
																	},
																},
																"one": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"fact": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `The numeric value extracted from input; The amount of digits. Not Null; must be one of ["numeric-value", "total-length"]`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																				stringvalidator.OneOf(
																					"numeric-value",
																					"total-length",
																				),
																			},
																		},
																		"operator": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Numeric comparison operator. Not Null; must be one of ["equal", "notEqual", "lessThan", "lessThanInclusive", "greaterThan", "greaterThanInclusive"]`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																				stringvalidator.OneOf(
																					"equal",
																					"notEqual",
																					"lessThan",
																					"lessThanInclusive",
																					"greaterThan",
																					"greaterThanInclusive",
																				),
																			},
																		},
																		"params": schema.SingleNestedAttribute{
																			Computed: true,
																			Optional: true,
																			Attributes: map[string]schema.Attribute{
																				"error_message": schema.StringAttribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `Custom error message`,
																				},
																			},
																			Description: `Additional parameters for the condition`,
																		},
																		"value": schema.Float64Attribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Numeric value to compare against. Not Null`,
																			Validators: []validator.Float64{
																				speakeasy_float64validators.NotNull(),
																			},
																		},
																	},
																	Description: `Numeric value comparison`,
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("two"),
																			path.MatchRelative().AtParent().AtName("three"),
																			path.MatchRelative().AtParent().AtName("four"),
																		}...),
																	},
																},
																"three": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"fact": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Count of decimal digits. Not Null; must be "decimal-digits-count"`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																				stringvalidator.OneOf(
																					"decimal-digits-count",
																				),
																			},
																		},
																		"operator": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Decimal digit count comparison operator. Not Null; must be one of ["equal", "minDecimalDigits", "maxDecimalDigits"]`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																				stringvalidator.OneOf(
																					"equal",
																					"minDecimalDigits",
																					"maxDecimalDigits",
																				),
																			},
																		},
																		"params": schema.SingleNestedAttribute{
																			Computed: true,
																			Optional: true,
																			Attributes: map[string]schema.Attribute{
																				"error_message": schema.StringAttribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `Custom error message`,
																				},
																			},
																			Description: `Additional parameters for the condition`,
																		},
																		"value": schema.Float64Attribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Expected number of decimal digits. Not Null`,
																			Validators: []validator.Float64{
																				speakeasy_float64validators.NotNull(),
																			},
																		},
																	},
																	Description: `Decimal digits count validation`,
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("one"),
																			path.MatchRelative().AtParent().AtName("two"),
																			path.MatchRelative().AtParent().AtName("four"),
																		}...),
																	},
																},
																"two": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"fact": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Count of integer digits (excludes leading zeros unless allowed). Not Null; must be "integer-digits-count"`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																				stringvalidator.OneOf(
																					"integer-digits-count",
																				),
																			},
																		},
																		"operator": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Digit count comparison operator. Not Null; must be one of ["equal", "exactlyNDigits", "minIntegerDigits", "maxIntegerDigits"]`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																				stringvalidator.OneOf(
																					"equal",
																					"exactlyNDigits",
																					"minIntegerDigits",
																					"maxIntegerDigits",
																				),
																			},
																		},
																		"params": schema.SingleNestedAttribute{
																			Computed: true,
																			Optional: true,
																			Attributes: map[string]schema.Attribute{
																				"allow_leading_zeroes": schema.BoolAttribute{
																					Computed:    true,
																					Optional:    true,
																					Default:     booldefault.StaticBool(false),
																					Description: `Whether to count leading zeroes in digit count. Default: false`,
																				},
																				"error_message": schema.StringAttribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `Custom error message`,
																				},
																			},
																			Description: `Additional parameters for the condition`,
																		},
																		"value": schema.Float64Attribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Expected number of integer digits. Not Null`,
																			Validators: []validator.Float64{
																				speakeasy_float64validators.NotNull(),
																			},
																		},
																	},
																	Description: `Integer digits count validation`,
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("one"),
																			path.MatchRelative().AtParent().AtName("three"),
																			path.MatchRelative().AtParent().AtName("four"),
																		}...),
																	},
																},
															},
															Description: `Fact-based condition for numeric validation`,
															Validators: []validator.Object{
																objectvalidator.ConflictsWith(path.Expressions{
																	path.MatchRelative().AtParent().AtName("numeric_nested_condition"),
																}...),
															},
														},
														"numeric_nested_condition": schema.SingleNestedAttribute{
															Computed: true,
															Optional: true,
															Attributes: map[string]schema.Attribute{
																"one": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"all": schema.ListNestedAttribute{
																			Computed: true,
																			Optional: true,
																			NestedObject: schema.NestedAttributeObject{
																				Validators: []validator.Object{
																					speakeasy_objectvalidators.NotNull(),
																				},
																				Attributes: map[string]schema.Attribute{
																					"four": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"fact": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Whether the input has leading zeros. Not Null; must be "has-leading-zeroes"`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"has-leading-zeroes",
																									),
																								},
																							},
																							"operator": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Leading zeros check operator. Not Null; must be one of ["equal", "notAllowed"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"equal",
																										"notAllowed",
																									),
																								},
																							},
																							"params": schema.SingleNestedAttribute{
																								Computed: true,
																								Optional: true,
																								Attributes: map[string]schema.Attribute{
																									"error_message": schema.StringAttribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `Custom error message`,
																									},
																								},
																								Description: `Additional parameters for the condition`,
																							},
																							"value": schema.BoolAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Whether leading zeros should be present or not. Not Null`,
																								Validators: []validator.Bool{
																									speakeasy_boolvalidators.NotNull(),
																								},
																							},
																						},
																						Description: `Leading zeros validation`,
																						Validators: []validator.Object{
																							objectvalidator.ConflictsWith(path.Expressions{
																								path.MatchRelative().AtParent().AtName("one"),
																								path.MatchRelative().AtParent().AtName("two"),
																								path.MatchRelative().AtParent().AtName("three"),
																							}...),
																						},
																					},
																					"one": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"fact": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `The numeric value extracted from input; The amount of digits. Not Null; must be one of ["numeric-value", "total-length"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"numeric-value",
																										"total-length",
																									),
																								},
																							},
																							"operator": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Numeric comparison operator. Not Null; must be one of ["equal", "notEqual", "lessThan", "lessThanInclusive", "greaterThan", "greaterThanInclusive"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"equal",
																										"notEqual",
																										"lessThan",
																										"lessThanInclusive",
																										"greaterThan",
																										"greaterThanInclusive",
																									),
																								},
																							},
																							"params": schema.SingleNestedAttribute{
																								Computed: true,
																								Optional: true,
																								Attributes: map[string]schema.Attribute{
																									"error_message": schema.StringAttribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `Custom error message`,
																									},
																								},
																								Description: `Additional parameters for the condition`,
																							},
																							"value": schema.Float64Attribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Numeric value to compare against. Not Null`,
																								Validators: []validator.Float64{
																									speakeasy_float64validators.NotNull(),
																								},
																							},
																						},
																						Description: `Numeric value comparison`,
																						Validators: []validator.Object{
																							objectvalidator.ConflictsWith(path.Expressions{
																								path.MatchRelative().AtParent().AtName("two"),
																								path.MatchRelative().AtParent().AtName("three"),
																								path.MatchRelative().AtParent().AtName("four"),
																							}...),
																						},
																					},
																					"three": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"fact": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Count of decimal digits. Not Null; must be "decimal-digits-count"`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"decimal-digits-count",
																									),
																								},
																							},
																							"operator": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Decimal digit count comparison operator. Not Null; must be one of ["equal", "minDecimalDigits", "maxDecimalDigits"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"equal",
																										"minDecimalDigits",
																										"maxDecimalDigits",
																									),
																								},
																							},
																							"params": schema.SingleNestedAttribute{
																								Computed: true,
																								Optional: true,
																								Attributes: map[string]schema.Attribute{
																									"error_message": schema.StringAttribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `Custom error message`,
																									},
																								},
																								Description: `Additional parameters for the condition`,
																							},
																							"value": schema.Float64Attribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Expected number of decimal digits. Not Null`,
																								Validators: []validator.Float64{
																									speakeasy_float64validators.NotNull(),
																								},
																							},
																						},
																						Description: `Decimal digits count validation`,
																						Validators: []validator.Object{
																							objectvalidator.ConflictsWith(path.Expressions{
																								path.MatchRelative().AtParent().AtName("one"),
																								path.MatchRelative().AtParent().AtName("two"),
																								path.MatchRelative().AtParent().AtName("four"),
																							}...),
																						},
																					},
																					"two": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"fact": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Count of integer digits (excludes leading zeros unless allowed). Not Null; must be "integer-digits-count"`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"integer-digits-count",
																									),
																								},
																							},
																							"operator": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Digit count comparison operator. Not Null; must be one of ["equal", "exactlyNDigits", "minIntegerDigits", "maxIntegerDigits"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"equal",
																										"exactlyNDigits",
																										"minIntegerDigits",
																										"maxIntegerDigits",
																									),
																								},
																							},
																							"params": schema.SingleNestedAttribute{
																								Computed: true,
																								Optional: true,
																								Attributes: map[string]schema.Attribute{
																									"allow_leading_zeroes": schema.BoolAttribute{
																										Computed:    true,
																										Optional:    true,
																										Default:     booldefault.StaticBool(false),
																										Description: `Whether to count leading zeroes in digit count. Default: false`,
																									},
																									"error_message": schema.StringAttribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `Custom error message`,
																									},
																								},
																								Description: `Additional parameters for the condition`,
																							},
																							"value": schema.Float64Attribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Expected number of integer digits. Not Null`,
																								Validators: []validator.Float64{
																									speakeasy_float64validators.NotNull(),
																								},
																							},
																						},
																						Description: `Integer digits count validation`,
																						Validators: []validator.Object{
																							objectvalidator.ConflictsWith(path.Expressions{
																								path.MatchRelative().AtParent().AtName("one"),
																								path.MatchRelative().AtParent().AtName("three"),
																								path.MatchRelative().AtParent().AtName("four"),
																							}...),
																						},
																					},
																				},
																			},
																			Description: `Not Null`,
																			Validators: []validator.List{
																				speakeasy_listvalidators.NotNull(),
																			},
																		},
																	},
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("two"),
																			path.MatchRelative().AtParent().AtName("three"),
																		}...),
																	},
																},
																"three": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"not": schema.SingleNestedAttribute{
																			Computed: true,
																			Optional: true,
																			Attributes: map[string]schema.Attribute{
																				"four": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"fact": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Whether the input has leading zeros. Not Null; must be "has-leading-zeroes"`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"has-leading-zeroes",
																								),
																							},
																						},
																						"operator": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Leading zeros check operator. Not Null; must be one of ["equal", "notAllowed"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"equal",
																									"notAllowed",
																								),
																							},
																						},
																						"params": schema.SingleNestedAttribute{
																							Computed: true,
																							Optional: true,
																							Attributes: map[string]schema.Attribute{
																								"error_message": schema.StringAttribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `Custom error message`,
																								},
																							},
																							Description: `Additional parameters for the condition`,
																						},
																						"value": schema.BoolAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Whether leading zeros should be present or not. Not Null`,
																							Validators: []validator.Bool{
																								speakeasy_boolvalidators.NotNull(),
																							},
																						},
																					},
																					Description: `Leading zeros validation`,
																					Validators: []validator.Object{
																						objectvalidator.ConflictsWith(path.Expressions{
																							path.MatchRelative().AtParent().AtName("one"),
																							path.MatchRelative().AtParent().AtName("two"),
																							path.MatchRelative().AtParent().AtName("three"),
																						}...),
																					},
																				},
																				"one": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"fact": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `The numeric value extracted from input; The amount of digits. Not Null; must be one of ["numeric-value", "total-length"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"numeric-value",
																									"total-length",
																								),
																							},
																						},
																						"operator": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Numeric comparison operator. Not Null; must be one of ["equal", "notEqual", "lessThan", "lessThanInclusive", "greaterThan", "greaterThanInclusive"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"equal",
																									"notEqual",
																									"lessThan",
																									"lessThanInclusive",
																									"greaterThan",
																									"greaterThanInclusive",
																								),
																							},
																						},
																						"params": schema.SingleNestedAttribute{
																							Computed: true,
																							Optional: true,
																							Attributes: map[string]schema.Attribute{
																								"error_message": schema.StringAttribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `Custom error message`,
																								},
																							},
																							Description: `Additional parameters for the condition`,
																						},
																						"value": schema.Float64Attribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Numeric value to compare against. Not Null`,
																							Validators: []validator.Float64{
																								speakeasy_float64validators.NotNull(),
																							},
																						},
																					},
																					Description: `Numeric value comparison`,
																					Validators: []validator.Object{
																						objectvalidator.ConflictsWith(path.Expressions{
																							path.MatchRelative().AtParent().AtName("two"),
																							path.MatchRelative().AtParent().AtName("three"),
																							path.MatchRelative().AtParent().AtName("four"),
																						}...),
																					},
																				},
																				"three": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"fact": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Count of decimal digits. Not Null; must be "decimal-digits-count"`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"decimal-digits-count",
																								),
																							},
																						},
																						"operator": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Decimal digit count comparison operator. Not Null; must be one of ["equal", "minDecimalDigits", "maxDecimalDigits"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"equal",
																									"minDecimalDigits",
																									"maxDecimalDigits",
																								),
																							},
																						},
																						"params": schema.SingleNestedAttribute{
																							Computed: true,
																							Optional: true,
																							Attributes: map[string]schema.Attribute{
																								"error_message": schema.StringAttribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `Custom error message`,
																								},
																							},
																							Description: `Additional parameters for the condition`,
																						},
																						"value": schema.Float64Attribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Expected number of decimal digits. Not Null`,
																							Validators: []validator.Float64{
																								speakeasy_float64validators.NotNull(),
																							},
																						},
																					},
																					Description: `Decimal digits count validation`,
																					Validators: []validator.Object{
																						objectvalidator.ConflictsWith(path.Expressions{
																							path.MatchRelative().AtParent().AtName("one"),
																							path.MatchRelative().AtParent().AtName("two"),
																							path.MatchRelative().AtParent().AtName("four"),
																						}...),
																					},
																				},
																				"two": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"fact": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Count of integer digits (excludes leading zeros unless allowed). Not Null; must be "integer-digits-count"`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"integer-digits-count",
																								),
																							},
																						},
																						"operator": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Digit count comparison operator. Not Null; must be one of ["equal", "exactlyNDigits", "minIntegerDigits", "maxIntegerDigits"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"equal",
																									"exactlyNDigits",
																									"minIntegerDigits",
																									"maxIntegerDigits",
																								),
																							},
																						},
																						"params": schema.SingleNestedAttribute{
																							Computed: true,
																							Optional: true,
																							Attributes: map[string]schema.Attribute{
																								"allow_leading_zeroes": schema.BoolAttribute{
																									Computed:    true,
																									Optional:    true,
																									Default:     booldefault.StaticBool(false),
																									Description: `Whether to count leading zeroes in digit count. Default: false`,
																								},
																								"error_message": schema.StringAttribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `Custom error message`,
																								},
																							},
																							Description: `Additional parameters for the condition`,
																						},
																						"value": schema.Float64Attribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Expected number of integer digits. Not Null`,
																							Validators: []validator.Float64{
																								speakeasy_float64validators.NotNull(),
																							},
																						},
																					},
																					Description: `Integer digits count validation`,
																					Validators: []validator.Object{
																						objectvalidator.ConflictsWith(path.Expressions{
																							path.MatchRelative().AtParent().AtName("one"),
																							path.MatchRelative().AtParent().AtName("three"),
																							path.MatchRelative().AtParent().AtName("four"),
																						}...),
																					},
																				},
																			},
																			Description: `Fact-based condition for numeric validation. Not Null`,
																			Validators: []validator.Object{
																				speakeasy_objectvalidators.NotNull(),
																			},
																		},
																	},
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("one"),
																			path.MatchRelative().AtParent().AtName("two"),
																		}...),
																	},
																},
																"two": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"any": schema.ListNestedAttribute{
																			Computed: true,
																			Optional: true,
																			NestedObject: schema.NestedAttributeObject{
																				Validators: []validator.Object{
																					speakeasy_objectvalidators.NotNull(),
																				},
																				Attributes: map[string]schema.Attribute{
																					"four": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"fact": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Whether the input has leading zeros. Not Null; must be "has-leading-zeroes"`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"has-leading-zeroes",
																									),
																								},
																							},
																							"operator": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Leading zeros check operator. Not Null; must be one of ["equal", "notAllowed"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"equal",
																										"notAllowed",
																									),
																								},
																							},
																							"params": schema.SingleNestedAttribute{
																								Computed: true,
																								Optional: true,
																								Attributes: map[string]schema.Attribute{
																									"error_message": schema.StringAttribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `Custom error message`,
																									},
																								},
																								Description: `Additional parameters for the condition`,
																							},
																							"value": schema.BoolAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Whether leading zeros should be present or not. Not Null`,
																								Validators: []validator.Bool{
																									speakeasy_boolvalidators.NotNull(),
																								},
																							},
																						},
																						Description: `Leading zeros validation`,
																						Validators: []validator.Object{
																							objectvalidator.ConflictsWith(path.Expressions{
																								path.MatchRelative().AtParent().AtName("one"),
																								path.MatchRelative().AtParent().AtName("two"),
																								path.MatchRelative().AtParent().AtName("three"),
																							}...),
																						},
																					},
																					"one": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"fact": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `The numeric value extracted from input; The amount of digits. Not Null; must be one of ["numeric-value", "total-length"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"numeric-value",
																										"total-length",
																									),
																								},
																							},
																							"operator": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Numeric comparison operator. Not Null; must be one of ["equal", "notEqual", "lessThan", "lessThanInclusive", "greaterThan", "greaterThanInclusive"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"equal",
																										"notEqual",
																										"lessThan",
																										"lessThanInclusive",
																										"greaterThan",
																										"greaterThanInclusive",
																									),
																								},
																							},
																							"params": schema.SingleNestedAttribute{
																								Computed: true,
																								Optional: true,
																								Attributes: map[string]schema.Attribute{
																									"error_message": schema.StringAttribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `Custom error message`,
																									},
																								},
																								Description: `Additional parameters for the condition`,
																							},
																							"value": schema.Float64Attribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Numeric value to compare against. Not Null`,
																								Validators: []validator.Float64{
																									speakeasy_float64validators.NotNull(),
																								},
																							},
																						},
																						Description: `Numeric value comparison`,
																						Validators: []validator.Object{
																							objectvalidator.ConflictsWith(path.Expressions{
																								path.MatchRelative().AtParent().AtName("two"),
																								path.MatchRelative().AtParent().AtName("three"),
																								path.MatchRelative().AtParent().AtName("four"),
																							}...),
																						},
																					},
																					"three": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"fact": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Count of decimal digits. Not Null; must be "decimal-digits-count"`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"decimal-digits-count",
																									),
																								},
																							},
																							"operator": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Decimal digit count comparison operator. Not Null; must be one of ["equal", "minDecimalDigits", "maxDecimalDigits"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"equal",
																										"minDecimalDigits",
																										"maxDecimalDigits",
																									),
																								},
																							},
																							"params": schema.SingleNestedAttribute{
																								Computed: true,
																								Optional: true,
																								Attributes: map[string]schema.Attribute{
																									"error_message": schema.StringAttribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `Custom error message`,
																									},
																								},
																								Description: `Additional parameters for the condition`,
																							},
																							"value": schema.Float64Attribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Expected number of decimal digits. Not Null`,
																								Validators: []validator.Float64{
																									speakeasy_float64validators.NotNull(),
																								},
																							},
																						},
																						Description: `Decimal digits count validation`,
																						Validators: []validator.Object{
																							objectvalidator.ConflictsWith(path.Expressions{
																								path.MatchRelative().AtParent().AtName("one"),
																								path.MatchRelative().AtParent().AtName("two"),
																								path.MatchRelative().AtParent().AtName("four"),
																							}...),
																						},
																					},
																					"two": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"fact": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Count of integer digits (excludes leading zeros unless allowed). Not Null; must be "integer-digits-count"`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"integer-digits-count",
																									),
																								},
																							},
																							"operator": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Digit count comparison operator. Not Null; must be one of ["equal", "exactlyNDigits", "minIntegerDigits", "maxIntegerDigits"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"equal",
																										"exactlyNDigits",
																										"minIntegerDigits",
																										"maxIntegerDigits",
																									),
																								},
																							},
																							"params": schema.SingleNestedAttribute{
																								Computed: true,
																								Optional: true,
																								Attributes: map[string]schema.Attribute{
																									"allow_leading_zeroes": schema.BoolAttribute{
																										Computed:    true,
																										Optional:    true,
																										Default:     booldefault.StaticBool(false),
																										Description: `Whether to count leading zeroes in digit count. Default: false`,
																									},
																									"error_message": schema.StringAttribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `Custom error message`,
																									},
																								},
																								Description: `Additional parameters for the condition`,
																							},
																							"value": schema.Float64Attribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Expected number of integer digits. Not Null`,
																								Validators: []validator.Float64{
																									speakeasy_float64validators.NotNull(),
																								},
																							},
																						},
																						Description: `Integer digits count validation`,
																						Validators: []validator.Object{
																							objectvalidator.ConflictsWith(path.Expressions{
																								path.MatchRelative().AtParent().AtName("one"),
																								path.MatchRelative().AtParent().AtName("three"),
																								path.MatchRelative().AtParent().AtName("four"),
																							}...),
																						},
																					},
																				},
																			},
																			Description: `Not Null`,
																			Validators: []validator.List{
																				speakeasy_listvalidators.NotNull(),
																			},
																		},
																	},
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("one"),
																			path.MatchRelative().AtParent().AtName("three"),
																		}...),
																	},
																},
															},
															Description: `Nested condition with logical operators (level 2 only)`,
															Validators: []validator.Object{
																objectvalidator.ConflictsWith(path.Expressions{
																	path.MatchRelative().AtParent().AtName("numeric_fact_condition"),
																}...),
															},
														},
													},
												},
												Description: `Not Null`,
												Validators: []validator.List{
													speakeasy_listvalidators.NotNull(),
												},
											},
										},
										Description: `Any conditions must be true (OR logic)`,
										Validators: []validator.Object{
											objectvalidator.ConflictsWith(path.Expressions{
												path.MatchRelative().AtParent().AtName("one"),
												path.MatchRelative().AtParent().AtName("three"),
											}...),
										},
									},
								},
								Description: `Condition definition for a numeric-based validation rule (2 levels deep). Not Null`,
								Validators: []validator.Object{
									speakeasy_objectvalidators.NotNull(),
								},
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Description: `Indicates this is a numeric-based validation rule. Not Null; must be "numeric"`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf("numeric"),
								},
							},
						},
						Description: `Validation rule for numeric values, supporting range and digit count constraints.`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("pattern_rule_type"),
								path.MatchRelative().AtParent().AtName("regex_rule_type"),
							}...),
						},
					},
					"pattern_rule_type": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"conditions": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"one": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"all": schema.ListNestedAttribute{
												Computed: true,
												Optional: true,
												NestedObject: schema.NestedAttributeObject{
													Validators: []validator.Object{
														speakeasy_objectvalidators.NotNull(),
													},
													Attributes: map[string]schema.Attribute{
														"pattern_fact_condition": schema.SingleNestedAttribute{
															Computed: true,
															Optional: true,
															Attributes: map[string]schema.Attribute{
																"four": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"fact": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `The name of the value to validate. Not Null; must be "static-check"`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																				stringvalidator.OneOf(
																					"static-check",
																				),
																			},
																		},
																		"operator": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `String comparison operator. Not Null; must be one of ["equal", "notEqual"]`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																				stringvalidator.OneOf(
																					"equal",
																					"notEqual",
																				),
																			},
																		},
																		"params": schema.SingleNestedAttribute{
																			Computed: true,
																			Optional: true,
																			Attributes: map[string]schema.Attribute{
																				"end": schema.Float64Attribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `To where to check`,
																				},
																				"error_message": schema.StringAttribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `Custom error message`,
																				},
																				"start": schema.Float64Attribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `From where to check`,
																				},
																			},
																			Description: `Additional parameters for the condition`,
																		},
																		"value": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `String value to compare against. Not Null`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																			},
																		},
																	},
																	Description: `String-based condition`,
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("one"),
																			path.MatchRelative().AtParent().AtName("two"),
																			path.MatchRelative().AtParent().AtName("three"),
																		}...),
																	},
																},
																"one": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"fact": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `The name of the value to validate. Not Null; must be "total-length"`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																				stringvalidator.OneOf(
																					"total-length",
																				),
																			},
																		},
																		"operator": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Numeric comparison operator. Not Null; must be one of ["equal", "notEqual", "lessThan", "lessThanInclusive", "greaterThan", "greaterThanInclusive"]`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																				stringvalidator.OneOf(
																					"equal",
																					"notEqual",
																					"lessThan",
																					"lessThanInclusive",
																					"greaterThan",
																					"greaterThanInclusive",
																				),
																			},
																		},
																		"params": schema.SingleNestedAttribute{
																			Computed: true,
																			Optional: true,
																			Attributes: map[string]schema.Attribute{
																				"end": schema.Float64Attribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `To where to check`,
																				},
																				"error_message": schema.StringAttribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `Custom error message`,
																				},
																				"start": schema.Float64Attribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `From where to check`,
																				},
																			},
																			Description: `Additional parameters for the condition`,
																		},
																		"value": schema.Float64Attribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Numeric value to compare against. Not Null`,
																			Validators: []validator.Float64{
																				speakeasy_float64validators.NotNull(),
																			},
																		},
																	},
																	Description: `Numeric condition (total-length fact)`,
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("two"),
																			path.MatchRelative().AtParent().AtName("three"),
																			path.MatchRelative().AtParent().AtName("four"),
																		}...),
																	},
																},
																"three": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"fact": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `The name of the value to validate. Not Null; must be "static-check"`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																				stringvalidator.OneOf(
																					"static-check",
																				),
																			},
																		},
																		"operator": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Array-based comparison operator. Not Null; must be one of ["in", "notIn", "contains", "doesNotContain"]`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																				stringvalidator.OneOf(
																					"in",
																					"notIn",
																					"contains",
																					"doesNotContain",
																				),
																			},
																		},
																		"params": schema.SingleNestedAttribute{
																			Computed: true,
																			Optional: true,
																			Attributes: map[string]schema.Attribute{
																				"end": schema.Float64Attribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `To where to check`,
																				},
																				"error_message": schema.StringAttribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `Custom error message`,
																				},
																				"start": schema.Float64Attribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `From where to check`,
																				},
																			},
																			Description: `Additional parameters for the condition`,
																		},
																		"value": schema.ListAttribute{
																			Computed:    true,
																			Optional:    true,
																			ElementType: types.StringType,
																			Description: `Array of string values for array-based operators. Not Null`,
																			Validators: []validator.List{
																				speakeasy_listvalidators.NotNull(),
																			},
																		},
																	},
																	Description: `Array-based condition (in, notIn, contains, doesNotContain)`,
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("one"),
																			path.MatchRelative().AtParent().AtName("two"),
																			path.MatchRelative().AtParent().AtName("four"),
																		}...),
																	},
																},
																"two": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"fact": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `The name of the value to validate. Not Null; must be one of ["static-check", "total-length"]`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																				stringvalidator.OneOf(
																					"static-check",
																					"total-length",
																				),
																			},
																		},
																		"operator": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Exact digit count operator. Not Null; must be "exactlyNDigits"`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																				stringvalidator.OneOf(
																					"exactlyNDigits",
																				),
																			},
																		},
																		"params": schema.SingleNestedAttribute{
																			Computed: true,
																			Optional: true,
																			Attributes: map[string]schema.Attribute{
																				"end": schema.Float64Attribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `To where to check`,
																				},
																				"error_message": schema.StringAttribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `Custom error message`,
																				},
																				"start": schema.Float64Attribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `From where to check`,
																				},
																			},
																			Description: `Additional parameters for the condition`,
																		},
																		"value": schema.Float64Attribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Number of digits required. Not Null`,
																			Validators: []validator.Float64{
																				speakeasy_float64validators.NotNull(),
																			},
																		},
																	},
																	Description: `Exact digits condition`,
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("one"),
																			path.MatchRelative().AtParent().AtName("three"),
																			path.MatchRelative().AtParent().AtName("four"),
																		}...),
																	},
																},
															},
															Description: `Fact-based condition for pattern validation`,
															Validators: []validator.Object{
																objectvalidator.ConflictsWith(path.Expressions{
																	path.MatchRelative().AtParent().AtName("pattern_nested_condition"),
																}...),
															},
														},
														"pattern_nested_condition": schema.SingleNestedAttribute{
															Computed: true,
															Optional: true,
															Attributes: map[string]schema.Attribute{
																"one": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"all": schema.ListNestedAttribute{
																			Computed: true,
																			Optional: true,
																			NestedObject: schema.NestedAttributeObject{
																				Validators: []validator.Object{
																					speakeasy_objectvalidators.NotNull(),
																				},
																				Attributes: map[string]schema.Attribute{
																					"four": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"fact": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `The name of the value to validate. Not Null; must be "static-check"`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"static-check",
																									),
																								},
																							},
																							"operator": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `String comparison operator. Not Null; must be one of ["equal", "notEqual"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"equal",
																										"notEqual",
																									),
																								},
																							},
																							"params": schema.SingleNestedAttribute{
																								Computed: true,
																								Optional: true,
																								Attributes: map[string]schema.Attribute{
																									"end": schema.Float64Attribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `To where to check`,
																									},
																									"error_message": schema.StringAttribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `Custom error message`,
																									},
																									"start": schema.Float64Attribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `From where to check`,
																									},
																								},
																								Description: `Additional parameters for the condition`,
																							},
																							"value": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `String value to compare against. Not Null`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																								},
																							},
																						},
																						Description: `String-based condition`,
																						Validators: []validator.Object{
																							objectvalidator.ConflictsWith(path.Expressions{
																								path.MatchRelative().AtParent().AtName("one"),
																								path.MatchRelative().AtParent().AtName("two"),
																								path.MatchRelative().AtParent().AtName("three"),
																							}...),
																						},
																					},
																					"one": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"fact": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `The name of the value to validate. Not Null; must be "total-length"`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"total-length",
																									),
																								},
																							},
																							"operator": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Numeric comparison operator. Not Null; must be one of ["equal", "notEqual", "lessThan", "lessThanInclusive", "greaterThan", "greaterThanInclusive"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"equal",
																										"notEqual",
																										"lessThan",
																										"lessThanInclusive",
																										"greaterThan",
																										"greaterThanInclusive",
																									),
																								},
																							},
																							"params": schema.SingleNestedAttribute{
																								Computed: true,
																								Optional: true,
																								Attributes: map[string]schema.Attribute{
																									"end": schema.Float64Attribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `To where to check`,
																									},
																									"error_message": schema.StringAttribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `Custom error message`,
																									},
																									"start": schema.Float64Attribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `From where to check`,
																									},
																								},
																								Description: `Additional parameters for the condition`,
																							},
																							"value": schema.Float64Attribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Numeric value to compare against. Not Null`,
																								Validators: []validator.Float64{
																									speakeasy_float64validators.NotNull(),
																								},
																							},
																						},
																						Description: `Numeric condition (total-length fact)`,
																						Validators: []validator.Object{
																							objectvalidator.ConflictsWith(path.Expressions{
																								path.MatchRelative().AtParent().AtName("two"),
																								path.MatchRelative().AtParent().AtName("three"),
																								path.MatchRelative().AtParent().AtName("four"),
																							}...),
																						},
																					},
																					"three": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"fact": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `The name of the value to validate. Not Null; must be "static-check"`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"static-check",
																									),
																								},
																							},
																							"operator": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Array-based comparison operator. Not Null; must be one of ["in", "notIn", "contains", "doesNotContain"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"in",
																										"notIn",
																										"contains",
																										"doesNotContain",
																									),
																								},
																							},
																							"params": schema.SingleNestedAttribute{
																								Computed: true,
																								Optional: true,
																								Attributes: map[string]schema.Attribute{
																									"end": schema.Float64Attribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `To where to check`,
																									},
																									"error_message": schema.StringAttribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `Custom error message`,
																									},
																									"start": schema.Float64Attribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `From where to check`,
																									},
																								},
																								Description: `Additional parameters for the condition`,
																							},
																							"value": schema.ListAttribute{
																								Computed:    true,
																								Optional:    true,
																								ElementType: types.StringType,
																								Description: `Array of string values for array-based operators. Not Null`,
																								Validators: []validator.List{
																									speakeasy_listvalidators.NotNull(),
																								},
																							},
																						},
																						Description: `Array-based condition (in, notIn, contains, doesNotContain)`,
																						Validators: []validator.Object{
																							objectvalidator.ConflictsWith(path.Expressions{
																								path.MatchRelative().AtParent().AtName("one"),
																								path.MatchRelative().AtParent().AtName("two"),
																								path.MatchRelative().AtParent().AtName("four"),
																							}...),
																						},
																					},
																					"two": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"fact": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `The name of the value to validate. Not Null; must be one of ["static-check", "total-length"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"static-check",
																										"total-length",
																									),
																								},
																							},
																							"operator": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Exact digit count operator. Not Null; must be "exactlyNDigits"`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"exactlyNDigits",
																									),
																								},
																							},
																							"params": schema.SingleNestedAttribute{
																								Computed: true,
																								Optional: true,
																								Attributes: map[string]schema.Attribute{
																									"end": schema.Float64Attribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `To where to check`,
																									},
																									"error_message": schema.StringAttribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `Custom error message`,
																									},
																									"start": schema.Float64Attribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `From where to check`,
																									},
																								},
																								Description: `Additional parameters for the condition`,
																							},
																							"value": schema.Float64Attribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Number of digits required. Not Null`,
																								Validators: []validator.Float64{
																									speakeasy_float64validators.NotNull(),
																								},
																							},
																						},
																						Description: `Exact digits condition`,
																						Validators: []validator.Object{
																							objectvalidator.ConflictsWith(path.Expressions{
																								path.MatchRelative().AtParent().AtName("one"),
																								path.MatchRelative().AtParent().AtName("three"),
																								path.MatchRelative().AtParent().AtName("four"),
																							}...),
																						},
																					},
																				},
																			},
																			Description: `Not Null`,
																			Validators: []validator.List{
																				speakeasy_listvalidators.NotNull(),
																			},
																		},
																	},
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("two"),
																			path.MatchRelative().AtParent().AtName("three"),
																		}...),
																	},
																},
																"three": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"not": schema.SingleNestedAttribute{
																			Computed: true,
																			Optional: true,
																			Attributes: map[string]schema.Attribute{
																				"four": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"fact": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `The name of the value to validate. Not Null; must be "static-check"`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"static-check",
																								),
																							},
																						},
																						"operator": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `String comparison operator. Not Null; must be one of ["equal", "notEqual"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"equal",
																									"notEqual",
																								),
																							},
																						},
																						"params": schema.SingleNestedAttribute{
																							Computed: true,
																							Optional: true,
																							Attributes: map[string]schema.Attribute{
																								"end": schema.Float64Attribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `To where to check`,
																								},
																								"error_message": schema.StringAttribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `Custom error message`,
																								},
																								"start": schema.Float64Attribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `From where to check`,
																								},
																							},
																							Description: `Additional parameters for the condition`,
																						},
																						"value": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `String value to compare against. Not Null`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																							},
																						},
																					},
																					Description: `String-based condition`,
																					Validators: []validator.Object{
																						objectvalidator.ConflictsWith(path.Expressions{
																							path.MatchRelative().AtParent().AtName("one"),
																							path.MatchRelative().AtParent().AtName("two"),
																							path.MatchRelative().AtParent().AtName("three"),
																						}...),
																					},
																				},
																				"one": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"fact": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `The name of the value to validate. Not Null; must be "total-length"`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"total-length",
																								),
																							},
																						},
																						"operator": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Numeric comparison operator. Not Null; must be one of ["equal", "notEqual", "lessThan", "lessThanInclusive", "greaterThan", "greaterThanInclusive"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"equal",
																									"notEqual",
																									"lessThan",
																									"lessThanInclusive",
																									"greaterThan",
																									"greaterThanInclusive",
																								),
																							},
																						},
																						"params": schema.SingleNestedAttribute{
																							Computed: true,
																							Optional: true,
																							Attributes: map[string]schema.Attribute{
																								"end": schema.Float64Attribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `To where to check`,
																								},
																								"error_message": schema.StringAttribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `Custom error message`,
																								},
																								"start": schema.Float64Attribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `From where to check`,
																								},
																							},
																							Description: `Additional parameters for the condition`,
																						},
																						"value": schema.Float64Attribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Numeric value to compare against. Not Null`,
																							Validators: []validator.Float64{
																								speakeasy_float64validators.NotNull(),
																							},
																						},
																					},
																					Description: `Numeric condition (total-length fact)`,
																					Validators: []validator.Object{
																						objectvalidator.ConflictsWith(path.Expressions{
																							path.MatchRelative().AtParent().AtName("two"),
																							path.MatchRelative().AtParent().AtName("three"),
																							path.MatchRelative().AtParent().AtName("four"),
																						}...),
																					},
																				},
																				"three": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"fact": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `The name of the value to validate. Not Null; must be "static-check"`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"static-check",
																								),
																							},
																						},
																						"operator": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Array-based comparison operator. Not Null; must be one of ["in", "notIn", "contains", "doesNotContain"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"in",
																									"notIn",
																									"contains",
																									"doesNotContain",
																								),
																							},
																						},
																						"params": schema.SingleNestedAttribute{
																							Computed: true,
																							Optional: true,
																							Attributes: map[string]schema.Attribute{
																								"end": schema.Float64Attribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `To where to check`,
																								},
																								"error_message": schema.StringAttribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `Custom error message`,
																								},
																								"start": schema.Float64Attribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `From where to check`,
																								},
																							},
																							Description: `Additional parameters for the condition`,
																						},
																						"value": schema.ListAttribute{
																							Computed:    true,
																							Optional:    true,
																							ElementType: types.StringType,
																							Description: `Array of string values for array-based operators. Not Null`,
																							Validators: []validator.List{
																								speakeasy_listvalidators.NotNull(),
																							},
																						},
																					},
																					Description: `Array-based condition (in, notIn, contains, doesNotContain)`,
																					Validators: []validator.Object{
																						objectvalidator.ConflictsWith(path.Expressions{
																							path.MatchRelative().AtParent().AtName("one"),
																							path.MatchRelative().AtParent().AtName("two"),
																							path.MatchRelative().AtParent().AtName("four"),
																						}...),
																					},
																				},
																				"two": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"fact": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `The name of the value to validate. Not Null; must be one of ["static-check", "total-length"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"static-check",
																									"total-length",
																								),
																							},
																						},
																						"operator": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Exact digit count operator. Not Null; must be "exactlyNDigits"`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"exactlyNDigits",
																								),
																							},
																						},
																						"params": schema.SingleNestedAttribute{
																							Computed: true,
																							Optional: true,
																							Attributes: map[string]schema.Attribute{
																								"end": schema.Float64Attribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `To where to check`,
																								},
																								"error_message": schema.StringAttribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `Custom error message`,
																								},
																								"start": schema.Float64Attribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `From where to check`,
																								},
																							},
																							Description: `Additional parameters for the condition`,
																						},
																						"value": schema.Float64Attribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Number of digits required. Not Null`,
																							Validators: []validator.Float64{
																								speakeasy_float64validators.NotNull(),
																							},
																						},
																					},
																					Description: `Exact digits condition`,
																					Validators: []validator.Object{
																						objectvalidator.ConflictsWith(path.Expressions{
																							path.MatchRelative().AtParent().AtName("one"),
																							path.MatchRelative().AtParent().AtName("three"),
																							path.MatchRelative().AtParent().AtName("four"),
																						}...),
																					},
																				},
																			},
																			Description: `Fact-based condition for pattern validation. Not Null`,
																			Validators: []validator.Object{
																				speakeasy_objectvalidators.NotNull(),
																			},
																		},
																	},
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("one"),
																			path.MatchRelative().AtParent().AtName("two"),
																		}...),
																	},
																},
																"two": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"any": schema.ListNestedAttribute{
																			Computed: true,
																			Optional: true,
																			NestedObject: schema.NestedAttributeObject{
																				Validators: []validator.Object{
																					speakeasy_objectvalidators.NotNull(),
																				},
																				Attributes: map[string]schema.Attribute{
																					"four": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"fact": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `The name of the value to validate. Not Null; must be "static-check"`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"static-check",
																									),
																								},
																							},
																							"operator": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `String comparison operator. Not Null; must be one of ["equal", "notEqual"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"equal",
																										"notEqual",
																									),
																								},
																							},
																							"params": schema.SingleNestedAttribute{
																								Computed: true,
																								Optional: true,
																								Attributes: map[string]schema.Attribute{
																									"end": schema.Float64Attribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `To where to check`,
																									},
																									"error_message": schema.StringAttribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `Custom error message`,
																									},
																									"start": schema.Float64Attribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `From where to check`,
																									},
																								},
																								Description: `Additional parameters for the condition`,
																							},
																							"value": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `String value to compare against. Not Null`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																								},
																							},
																						},
																						Description: `String-based condition`,
																						Validators: []validator.Object{
																							objectvalidator.ConflictsWith(path.Expressions{
																								path.MatchRelative().AtParent().AtName("one"),
																								path.MatchRelative().AtParent().AtName("two"),
																								path.MatchRelative().AtParent().AtName("three"),
																							}...),
																						},
																					},
																					"one": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"fact": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `The name of the value to validate. Not Null; must be "total-length"`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"total-length",
																									),
																								},
																							},
																							"operator": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Numeric comparison operator. Not Null; must be one of ["equal", "notEqual", "lessThan", "lessThanInclusive", "greaterThan", "greaterThanInclusive"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"equal",
																										"notEqual",
																										"lessThan",
																										"lessThanInclusive",
																										"greaterThan",
																										"greaterThanInclusive",
																									),
																								},
																							},
																							"params": schema.SingleNestedAttribute{
																								Computed: true,
																								Optional: true,
																								Attributes: map[string]schema.Attribute{
																									"end": schema.Float64Attribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `To where to check`,
																									},
																									"error_message": schema.StringAttribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `Custom error message`,
																									},
																									"start": schema.Float64Attribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `From where to check`,
																									},
																								},
																								Description: `Additional parameters for the condition`,
																							},
																							"value": schema.Float64Attribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Numeric value to compare against. Not Null`,
																								Validators: []validator.Float64{
																									speakeasy_float64validators.NotNull(),
																								},
																							},
																						},
																						Description: `Numeric condition (total-length fact)`,
																						Validators: []validator.Object{
																							objectvalidator.ConflictsWith(path.Expressions{
																								path.MatchRelative().AtParent().AtName("two"),
																								path.MatchRelative().AtParent().AtName("three"),
																								path.MatchRelative().AtParent().AtName("four"),
																							}...),
																						},
																					},
																					"three": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"fact": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `The name of the value to validate. Not Null; must be "static-check"`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"static-check",
																									),
																								},
																							},
																							"operator": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Array-based comparison operator. Not Null; must be one of ["in", "notIn", "contains", "doesNotContain"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"in",
																										"notIn",
																										"contains",
																										"doesNotContain",
																									),
																								},
																							},
																							"params": schema.SingleNestedAttribute{
																								Computed: true,
																								Optional: true,
																								Attributes: map[string]schema.Attribute{
																									"end": schema.Float64Attribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `To where to check`,
																									},
																									"error_message": schema.StringAttribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `Custom error message`,
																									},
																									"start": schema.Float64Attribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `From where to check`,
																									},
																								},
																								Description: `Additional parameters for the condition`,
																							},
																							"value": schema.ListAttribute{
																								Computed:    true,
																								Optional:    true,
																								ElementType: types.StringType,
																								Description: `Array of string values for array-based operators. Not Null`,
																								Validators: []validator.List{
																									speakeasy_listvalidators.NotNull(),
																								},
																							},
																						},
																						Description: `Array-based condition (in, notIn, contains, doesNotContain)`,
																						Validators: []validator.Object{
																							objectvalidator.ConflictsWith(path.Expressions{
																								path.MatchRelative().AtParent().AtName("one"),
																								path.MatchRelative().AtParent().AtName("two"),
																								path.MatchRelative().AtParent().AtName("four"),
																							}...),
																						},
																					},
																					"two": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"fact": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `The name of the value to validate. Not Null; must be one of ["static-check", "total-length"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"static-check",
																										"total-length",
																									),
																								},
																							},
																							"operator": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Exact digit count operator. Not Null; must be "exactlyNDigits"`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"exactlyNDigits",
																									),
																								},
																							},
																							"params": schema.SingleNestedAttribute{
																								Computed: true,
																								Optional: true,
																								Attributes: map[string]schema.Attribute{
																									"end": schema.Float64Attribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `To where to check`,
																									},
																									"error_message": schema.StringAttribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `Custom error message`,
																									},
																									"start": schema.Float64Attribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `From where to check`,
																									},
																								},
																								Description: `Additional parameters for the condition`,
																							},
																							"value": schema.Float64Attribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Number of digits required. Not Null`,
																								Validators: []validator.Float64{
																									speakeasy_float64validators.NotNull(),
																								},
																							},
																						},
																						Description: `Exact digits condition`,
																						Validators: []validator.Object{
																							objectvalidator.ConflictsWith(path.Expressions{
																								path.MatchRelative().AtParent().AtName("one"),
																								path.MatchRelative().AtParent().AtName("three"),
																								path.MatchRelative().AtParent().AtName("four"),
																							}...),
																						},
																					},
																				},
																			},
																			Description: `Not Null`,
																			Validators: []validator.List{
																				speakeasy_listvalidators.NotNull(),
																			},
																		},
																	},
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("one"),
																			path.MatchRelative().AtParent().AtName("three"),
																		}...),
																	},
																},
															},
															Description: `Nested condition with logical operators (level 2 only)`,
															Validators: []validator.Object{
																objectvalidator.ConflictsWith(path.Expressions{
																	path.MatchRelative().AtParent().AtName("pattern_fact_condition"),
																}...),
															},
														},
													},
												},
												Description: `Not Null`,
												Validators: []validator.List{
													speakeasy_listvalidators.NotNull(),
												},
											},
										},
										Description: `All conditions must be true (AND logic)`,
										Validators: []validator.Object{
											objectvalidator.ConflictsWith(path.Expressions{
												path.MatchRelative().AtParent().AtName("two"),
												path.MatchRelative().AtParent().AtName("three"),
											}...),
										},
									},
									"three": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"not": schema.SingleNestedAttribute{
												Computed: true,
												Optional: true,
												Attributes: map[string]schema.Attribute{
													"pattern_fact_condition": schema.SingleNestedAttribute{
														Computed: true,
														Optional: true,
														Attributes: map[string]schema.Attribute{
															"four": schema.SingleNestedAttribute{
																Computed: true,
																Optional: true,
																Attributes: map[string]schema.Attribute{
																	"fact": schema.StringAttribute{
																		Computed:    true,
																		Optional:    true,
																		Description: `The name of the value to validate. Not Null; must be "static-check"`,
																		Validators: []validator.String{
																			speakeasy_stringvalidators.NotNull(),
																			stringvalidator.OneOf(
																				"static-check",
																			),
																		},
																	},
																	"operator": schema.StringAttribute{
																		Computed:    true,
																		Optional:    true,
																		Description: `String comparison operator. Not Null; must be one of ["equal", "notEqual"]`,
																		Validators: []validator.String{
																			speakeasy_stringvalidators.NotNull(),
																			stringvalidator.OneOf(
																				"equal",
																				"notEqual",
																			),
																		},
																	},
																	"params": schema.SingleNestedAttribute{
																		Computed: true,
																		Optional: true,
																		Attributes: map[string]schema.Attribute{
																			"end": schema.Float64Attribute{
																				Computed:    true,
																				Optional:    true,
																				Description: `To where to check`,
																			},
																			"error_message": schema.StringAttribute{
																				Computed:    true,
																				Optional:    true,
																				Description: `Custom error message`,
																			},
																			"start": schema.Float64Attribute{
																				Computed:    true,
																				Optional:    true,
																				Description: `From where to check`,
																			},
																		},
																		Description: `Additional parameters for the condition`,
																	},
																	"value": schema.StringAttribute{
																		Computed:    true,
																		Optional:    true,
																		Description: `String value to compare against. Not Null`,
																		Validators: []validator.String{
																			speakeasy_stringvalidators.NotNull(),
																		},
																	},
																},
																Description: `String-based condition`,
																Validators: []validator.Object{
																	objectvalidator.ConflictsWith(path.Expressions{
																		path.MatchRelative().AtParent().AtName("one"),
																		path.MatchRelative().AtParent().AtName("two"),
																		path.MatchRelative().AtParent().AtName("three"),
																	}...),
																},
															},
															"one": schema.SingleNestedAttribute{
																Computed: true,
																Optional: true,
																Attributes: map[string]schema.Attribute{
																	"fact": schema.StringAttribute{
																		Computed:    true,
																		Optional:    true,
																		Description: `The name of the value to validate. Not Null; must be "total-length"`,
																		Validators: []validator.String{
																			speakeasy_stringvalidators.NotNull(),
																			stringvalidator.OneOf(
																				"total-length",
																			),
																		},
																	},
																	"operator": schema.StringAttribute{
																		Computed:    true,
																		Optional:    true,
																		Description: `Numeric comparison operator. Not Null; must be one of ["equal", "notEqual", "lessThan", "lessThanInclusive", "greaterThan", "greaterThanInclusive"]`,
																		Validators: []validator.String{
																			speakeasy_stringvalidators.NotNull(),
																			stringvalidator.OneOf(
																				"equal",
																				"notEqual",
																				"lessThan",
																				"lessThanInclusive",
																				"greaterThan",
																				"greaterThanInclusive",
																			),
																		},
																	},
																	"params": schema.SingleNestedAttribute{
																		Computed: true,
																		Optional: true,
																		Attributes: map[string]schema.Attribute{
																			"end": schema.Float64Attribute{
																				Computed:    true,
																				Optional:    true,
																				Description: `To where to check`,
																			},
																			"error_message": schema.StringAttribute{
																				Computed:    true,
																				Optional:    true,
																				Description: `Custom error message`,
																			},
																			"start": schema.Float64Attribute{
																				Computed:    true,
																				Optional:    true,
																				Description: `From where to check`,
																			},
																		},
																		Description: `Additional parameters for the condition`,
																	},
																	"value": schema.Float64Attribute{
																		Computed:    true,
																		Optional:    true,
																		Description: `Numeric value to compare against. Not Null`,
																		Validators: []validator.Float64{
																			speakeasy_float64validators.NotNull(),
																		},
																	},
																},
																Description: `Numeric condition (total-length fact)`,
																Validators: []validator.Object{
																	objectvalidator.ConflictsWith(path.Expressions{
																		path.MatchRelative().AtParent().AtName("two"),
																		path.MatchRelative().AtParent().AtName("three"),
																		path.MatchRelative().AtParent().AtName("four"),
																	}...),
																},
															},
															"three": schema.SingleNestedAttribute{
																Computed: true,
																Optional: true,
																Attributes: map[string]schema.Attribute{
																	"fact": schema.StringAttribute{
																		Computed:    true,
																		Optional:    true,
																		Description: `The name of the value to validate. Not Null; must be "static-check"`,
																		Validators: []validator.String{
																			speakeasy_stringvalidators.NotNull(),
																			stringvalidator.OneOf(
																				"static-check",
																			),
																		},
																	},
																	"operator": schema.StringAttribute{
																		Computed:    true,
																		Optional:    true,
																		Description: `Array-based comparison operator. Not Null; must be one of ["in", "notIn", "contains", "doesNotContain"]`,
																		Validators: []validator.String{
																			speakeasy_stringvalidators.NotNull(),
																			stringvalidator.OneOf(
																				"in",
																				"notIn",
																				"contains",
																				"doesNotContain",
																			),
																		},
																	},
																	"params": schema.SingleNestedAttribute{
																		Computed: true,
																		Optional: true,
																		Attributes: map[string]schema.Attribute{
																			"end": schema.Float64Attribute{
																				Computed:    true,
																				Optional:    true,
																				Description: `To where to check`,
																			},
																			"error_message": schema.StringAttribute{
																				Computed:    true,
																				Optional:    true,
																				Description: `Custom error message`,
																			},
																			"start": schema.Float64Attribute{
																				Computed:    true,
																				Optional:    true,
																				Description: `From where to check`,
																			},
																		},
																		Description: `Additional parameters for the condition`,
																	},
																	"value": schema.ListAttribute{
																		Computed:    true,
																		Optional:    true,
																		ElementType: types.StringType,
																		Description: `Array of string values for array-based operators. Not Null`,
																		Validators: []validator.List{
																			speakeasy_listvalidators.NotNull(),
																		},
																	},
																},
																Description: `Array-based condition (in, notIn, contains, doesNotContain)`,
																Validators: []validator.Object{
																	objectvalidator.ConflictsWith(path.Expressions{
																		path.MatchRelative().AtParent().AtName("one"),
																		path.MatchRelative().AtParent().AtName("two"),
																		path.MatchRelative().AtParent().AtName("four"),
																	}...),
																},
															},
															"two": schema.SingleNestedAttribute{
																Computed: true,
																Optional: true,
																Attributes: map[string]schema.Attribute{
																	"fact": schema.StringAttribute{
																		Computed:    true,
																		Optional:    true,
																		Description: `The name of the value to validate. Not Null; must be one of ["static-check", "total-length"]`,
																		Validators: []validator.String{
																			speakeasy_stringvalidators.NotNull(),
																			stringvalidator.OneOf(
																				"static-check",
																				"total-length",
																			),
																		},
																	},
																	"operator": schema.StringAttribute{
																		Computed:    true,
																		Optional:    true,
																		Description: `Exact digit count operator. Not Null; must be "exactlyNDigits"`,
																		Validators: []validator.String{
																			speakeasy_stringvalidators.NotNull(),
																			stringvalidator.OneOf(
																				"exactlyNDigits",
																			),
																		},
																	},
																	"params": schema.SingleNestedAttribute{
																		Computed: true,
																		Optional: true,
																		Attributes: map[string]schema.Attribute{
																			"end": schema.Float64Attribute{
																				Computed:    true,
																				Optional:    true,
																				Description: `To where to check`,
																			},
																			"error_message": schema.StringAttribute{
																				Computed:    true,
																				Optional:    true,
																				Description: `Custom error message`,
																			},
																			"start": schema.Float64Attribute{
																				Computed:    true,
																				Optional:    true,
																				Description: `From where to check`,
																			},
																		},
																		Description: `Additional parameters for the condition`,
																	},
																	"value": schema.Float64Attribute{
																		Computed:    true,
																		Optional:    true,
																		Description: `Number of digits required. Not Null`,
																		Validators: []validator.Float64{
																			speakeasy_float64validators.NotNull(),
																		},
																	},
																},
																Description: `Exact digits condition`,
																Validators: []validator.Object{
																	objectvalidator.ConflictsWith(path.Expressions{
																		path.MatchRelative().AtParent().AtName("one"),
																		path.MatchRelative().AtParent().AtName("three"),
																		path.MatchRelative().AtParent().AtName("four"),
																	}...),
																},
															},
														},
														Description: `Fact-based condition for pattern validation`,
														Validators: []validator.Object{
															objectvalidator.ConflictsWith(path.Expressions{
																path.MatchRelative().AtParent().AtName("pattern_nested_condition"),
															}...),
														},
													},
													"pattern_nested_condition": schema.SingleNestedAttribute{
														Computed: true,
														Optional: true,
														Attributes: map[string]schema.Attribute{
															"one": schema.SingleNestedAttribute{
																Computed: true,
																Optional: true,
																Attributes: map[string]schema.Attribute{
																	"all": schema.ListNestedAttribute{
																		Computed: true,
																		Optional: true,
																		NestedObject: schema.NestedAttributeObject{
																			Validators: []validator.Object{
																				speakeasy_objectvalidators.NotNull(),
																			},
																			Attributes: map[string]schema.Attribute{
																				"four": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"fact": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `The name of the value to validate. Not Null; must be "static-check"`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"static-check",
																								),
																							},
																						},
																						"operator": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `String comparison operator. Not Null; must be one of ["equal", "notEqual"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"equal",
																									"notEqual",
																								),
																							},
																						},
																						"params": schema.SingleNestedAttribute{
																							Computed: true,
																							Optional: true,
																							Attributes: map[string]schema.Attribute{
																								"end": schema.Float64Attribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `To where to check`,
																								},
																								"error_message": schema.StringAttribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `Custom error message`,
																								},
																								"start": schema.Float64Attribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `From where to check`,
																								},
																							},
																							Description: `Additional parameters for the condition`,
																						},
																						"value": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `String value to compare against. Not Null`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																							},
																						},
																					},
																					Description: `String-based condition`,
																					Validators: []validator.Object{
																						objectvalidator.ConflictsWith(path.Expressions{
																							path.MatchRelative().AtParent().AtName("one"),
																							path.MatchRelative().AtParent().AtName("two"),
																							path.MatchRelative().AtParent().AtName("three"),
																						}...),
																					},
																				},
																				"one": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"fact": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `The name of the value to validate. Not Null; must be "total-length"`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"total-length",
																								),
																							},
																						},
																						"operator": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Numeric comparison operator. Not Null; must be one of ["equal", "notEqual", "lessThan", "lessThanInclusive", "greaterThan", "greaterThanInclusive"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"equal",
																									"notEqual",
																									"lessThan",
																									"lessThanInclusive",
																									"greaterThan",
																									"greaterThanInclusive",
																								),
																							},
																						},
																						"params": schema.SingleNestedAttribute{
																							Computed: true,
																							Optional: true,
																							Attributes: map[string]schema.Attribute{
																								"end": schema.Float64Attribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `To where to check`,
																								},
																								"error_message": schema.StringAttribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `Custom error message`,
																								},
																								"start": schema.Float64Attribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `From where to check`,
																								},
																							},
																							Description: `Additional parameters for the condition`,
																						},
																						"value": schema.Float64Attribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Numeric value to compare against. Not Null`,
																							Validators: []validator.Float64{
																								speakeasy_float64validators.NotNull(),
																							},
																						},
																					},
																					Description: `Numeric condition (total-length fact)`,
																					Validators: []validator.Object{
																						objectvalidator.ConflictsWith(path.Expressions{
																							path.MatchRelative().AtParent().AtName("two"),
																							path.MatchRelative().AtParent().AtName("three"),
																							path.MatchRelative().AtParent().AtName("four"),
																						}...),
																					},
																				},
																				"three": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"fact": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `The name of the value to validate. Not Null; must be "static-check"`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"static-check",
																								),
																							},
																						},
																						"operator": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Array-based comparison operator. Not Null; must be one of ["in", "notIn", "contains", "doesNotContain"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"in",
																									"notIn",
																									"contains",
																									"doesNotContain",
																								),
																							},
																						},
																						"params": schema.SingleNestedAttribute{
																							Computed: true,
																							Optional: true,
																							Attributes: map[string]schema.Attribute{
																								"end": schema.Float64Attribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `To where to check`,
																								},
																								"error_message": schema.StringAttribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `Custom error message`,
																								},
																								"start": schema.Float64Attribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `From where to check`,
																								},
																							},
																							Description: `Additional parameters for the condition`,
																						},
																						"value": schema.ListAttribute{
																							Computed:    true,
																							Optional:    true,
																							ElementType: types.StringType,
																							Description: `Array of string values for array-based operators. Not Null`,
																							Validators: []validator.List{
																								speakeasy_listvalidators.NotNull(),
																							},
																						},
																					},
																					Description: `Array-based condition (in, notIn, contains, doesNotContain)`,
																					Validators: []validator.Object{
																						objectvalidator.ConflictsWith(path.Expressions{
																							path.MatchRelative().AtParent().AtName("one"),
																							path.MatchRelative().AtParent().AtName("two"),
																							path.MatchRelative().AtParent().AtName("four"),
																						}...),
																					},
																				},
																				"two": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"fact": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `The name of the value to validate. Not Null; must be one of ["static-check", "total-length"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"static-check",
																									"total-length",
																								),
																							},
																						},
																						"operator": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Exact digit count operator. Not Null; must be "exactlyNDigits"`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"exactlyNDigits",
																								),
																							},
																						},
																						"params": schema.SingleNestedAttribute{
																							Computed: true,
																							Optional: true,
																							Attributes: map[string]schema.Attribute{
																								"end": schema.Float64Attribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `To where to check`,
																								},
																								"error_message": schema.StringAttribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `Custom error message`,
																								},
																								"start": schema.Float64Attribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `From where to check`,
																								},
																							},
																							Description: `Additional parameters for the condition`,
																						},
																						"value": schema.Float64Attribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Number of digits required. Not Null`,
																							Validators: []validator.Float64{
																								speakeasy_float64validators.NotNull(),
																							},
																						},
																					},
																					Description: `Exact digits condition`,
																					Validators: []validator.Object{
																						objectvalidator.ConflictsWith(path.Expressions{
																							path.MatchRelative().AtParent().AtName("one"),
																							path.MatchRelative().AtParent().AtName("three"),
																							path.MatchRelative().AtParent().AtName("four"),
																						}...),
																					},
																				},
																			},
																		},
																		Description: `Not Null`,
																		Validators: []validator.List{
																			speakeasy_listvalidators.NotNull(),
																		},
																	},
																},
																Validators: []validator.Object{
																	objectvalidator.ConflictsWith(path.Expressions{
																		path.MatchRelative().AtParent().AtName("two"),
																		path.MatchRelative().AtParent().AtName("three"),
																	}...),
																},
															},
															"three": schema.SingleNestedAttribute{
																Computed: true,
																Optional: true,
																Attributes: map[string]schema.Attribute{
																	"not": schema.SingleNestedAttribute{
																		Computed: true,
																		Optional: true,
																		Attributes: map[string]schema.Attribute{
																			"four": schema.SingleNestedAttribute{
																				Computed: true,
																				Optional: true,
																				Attributes: map[string]schema.Attribute{
																					"fact": schema.StringAttribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `The name of the value to validate. Not Null; must be "static-check"`,
																						Validators: []validator.String{
																							speakeasy_stringvalidators.NotNull(),
																							stringvalidator.OneOf(
																								"static-check",
																							),
																						},
																					},
																					"operator": schema.StringAttribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `String comparison operator. Not Null; must be one of ["equal", "notEqual"]`,
																						Validators: []validator.String{
																							speakeasy_stringvalidators.NotNull(),
																							stringvalidator.OneOf(
																								"equal",
																								"notEqual",
																							),
																						},
																					},
																					"params": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"end": schema.Float64Attribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `To where to check`,
																							},
																							"error_message": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Custom error message`,
																							},
																							"start": schema.Float64Attribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `From where to check`,
																							},
																						},
																						Description: `Additional parameters for the condition`,
																					},
																					"value": schema.StringAttribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `String value to compare against. Not Null`,
																						Validators: []validator.String{
																							speakeasy_stringvalidators.NotNull(),
																						},
																					},
																				},
																				Description: `String-based condition`,
																				Validators: []validator.Object{
																					objectvalidator.ConflictsWith(path.Expressions{
																						path.MatchRelative().AtParent().AtName("one"),
																						path.MatchRelative().AtParent().AtName("two"),
																						path.MatchRelative().AtParent().AtName("three"),
																					}...),
																				},
																			},
																			"one": schema.SingleNestedAttribute{
																				Computed: true,
																				Optional: true,
																				Attributes: map[string]schema.Attribute{
																					"fact": schema.StringAttribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `The name of the value to validate. Not Null; must be "total-length"`,
																						Validators: []validator.String{
																							speakeasy_stringvalidators.NotNull(),
																							stringvalidator.OneOf(
																								"total-length",
																							),
																						},
																					},
																					"operator": schema.StringAttribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `Numeric comparison operator. Not Null; must be one of ["equal", "notEqual", "lessThan", "lessThanInclusive", "greaterThan", "greaterThanInclusive"]`,
																						Validators: []validator.String{
																							speakeasy_stringvalidators.NotNull(),
																							stringvalidator.OneOf(
																								"equal",
																								"notEqual",
																								"lessThan",
																								"lessThanInclusive",
																								"greaterThan",
																								"greaterThanInclusive",
																							),
																						},
																					},
																					"params": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"end": schema.Float64Attribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `To where to check`,
																							},
																							"error_message": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Custom error message`,
																							},
																							"start": schema.Float64Attribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `From where to check`,
																							},
																						},
																						Description: `Additional parameters for the condition`,
																					},
																					"value": schema.Float64Attribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `Numeric value to compare against. Not Null`,
																						Validators: []validator.Float64{
																							speakeasy_float64validators.NotNull(),
																						},
																					},
																				},
																				Description: `Numeric condition (total-length fact)`,
																				Validators: []validator.Object{
																					objectvalidator.ConflictsWith(path.Expressions{
																						path.MatchRelative().AtParent().AtName("two"),
																						path.MatchRelative().AtParent().AtName("three"),
																						path.MatchRelative().AtParent().AtName("four"),
																					}...),
																				},
																			},
																			"three": schema.SingleNestedAttribute{
																				Computed: true,
																				Optional: true,
																				Attributes: map[string]schema.Attribute{
																					"fact": schema.StringAttribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `The name of the value to validate. Not Null; must be "static-check"`,
																						Validators: []validator.String{
																							speakeasy_stringvalidators.NotNull(),
																							stringvalidator.OneOf(
																								"static-check",
																							),
																						},
																					},
																					"operator": schema.StringAttribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `Array-based comparison operator. Not Null; must be one of ["in", "notIn", "contains", "doesNotContain"]`,
																						Validators: []validator.String{
																							speakeasy_stringvalidators.NotNull(),
																							stringvalidator.OneOf(
																								"in",
																								"notIn",
																								"contains",
																								"doesNotContain",
																							),
																						},
																					},
																					"params": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"end": schema.Float64Attribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `To where to check`,
																							},
																							"error_message": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Custom error message`,
																							},
																							"start": schema.Float64Attribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `From where to check`,
																							},
																						},
																						Description: `Additional parameters for the condition`,
																					},
																					"value": schema.ListAttribute{
																						Computed:    true,
																						Optional:    true,
																						ElementType: types.StringType,
																						Description: `Array of string values for array-based operators. Not Null`,
																						Validators: []validator.List{
																							speakeasy_listvalidators.NotNull(),
																						},
																					},
																				},
																				Description: `Array-based condition (in, notIn, contains, doesNotContain)`,
																				Validators: []validator.Object{
																					objectvalidator.ConflictsWith(path.Expressions{
																						path.MatchRelative().AtParent().AtName("one"),
																						path.MatchRelative().AtParent().AtName("two"),
																						path.MatchRelative().AtParent().AtName("four"),
																					}...),
																				},
																			},
																			"two": schema.SingleNestedAttribute{
																				Computed: true,
																				Optional: true,
																				Attributes: map[string]schema.Attribute{
																					"fact": schema.StringAttribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `The name of the value to validate. Not Null; must be one of ["static-check", "total-length"]`,
																						Validators: []validator.String{
																							speakeasy_stringvalidators.NotNull(),
																							stringvalidator.OneOf(
																								"static-check",
																								"total-length",
																							),
																						},
																					},
																					"operator": schema.StringAttribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `Exact digit count operator. Not Null; must be "exactlyNDigits"`,
																						Validators: []validator.String{
																							speakeasy_stringvalidators.NotNull(),
																							stringvalidator.OneOf(
																								"exactlyNDigits",
																							),
																						},
																					},
																					"params": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"end": schema.Float64Attribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `To where to check`,
																							},
																							"error_message": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Custom error message`,
																							},
																							"start": schema.Float64Attribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `From where to check`,
																							},
																						},
																						Description: `Additional parameters for the condition`,
																					},
																					"value": schema.Float64Attribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `Number of digits required. Not Null`,
																						Validators: []validator.Float64{
																							speakeasy_float64validators.NotNull(),
																						},
																					},
																				},
																				Description: `Exact digits condition`,
																				Validators: []validator.Object{
																					objectvalidator.ConflictsWith(path.Expressions{
																						path.MatchRelative().AtParent().AtName("one"),
																						path.MatchRelative().AtParent().AtName("three"),
																						path.MatchRelative().AtParent().AtName("four"),
																					}...),
																				},
																			},
																		},
																		Description: `Fact-based condition for pattern validation. Not Null`,
																		Validators: []validator.Object{
																			speakeasy_objectvalidators.NotNull(),
																		},
																	},
																},
																Validators: []validator.Object{
																	objectvalidator.ConflictsWith(path.Expressions{
																		path.MatchRelative().AtParent().AtName("one"),
																		path.MatchRelative().AtParent().AtName("two"),
																	}...),
																},
															},
															"two": schema.SingleNestedAttribute{
																Computed: true,
																Optional: true,
																Attributes: map[string]schema.Attribute{
																	"any": schema.ListNestedAttribute{
																		Computed: true,
																		Optional: true,
																		NestedObject: schema.NestedAttributeObject{
																			Validators: []validator.Object{
																				speakeasy_objectvalidators.NotNull(),
																			},
																			Attributes: map[string]schema.Attribute{
																				"four": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"fact": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `The name of the value to validate. Not Null; must be "static-check"`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"static-check",
																								),
																							},
																						},
																						"operator": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `String comparison operator. Not Null; must be one of ["equal", "notEqual"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"equal",
																									"notEqual",
																								),
																							},
																						},
																						"params": schema.SingleNestedAttribute{
																							Computed: true,
																							Optional: true,
																							Attributes: map[string]schema.Attribute{
																								"end": schema.Float64Attribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `To where to check`,
																								},
																								"error_message": schema.StringAttribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `Custom error message`,
																								},
																								"start": schema.Float64Attribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `From where to check`,
																								},
																							},
																							Description: `Additional parameters for the condition`,
																						},
																						"value": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `String value to compare against. Not Null`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																							},
																						},
																					},
																					Description: `String-based condition`,
																					Validators: []validator.Object{
																						objectvalidator.ConflictsWith(path.Expressions{
																							path.MatchRelative().AtParent().AtName("one"),
																							path.MatchRelative().AtParent().AtName("two"),
																							path.MatchRelative().AtParent().AtName("three"),
																						}...),
																					},
																				},
																				"one": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"fact": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `The name of the value to validate. Not Null; must be "total-length"`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"total-length",
																								),
																							},
																						},
																						"operator": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Numeric comparison operator. Not Null; must be one of ["equal", "notEqual", "lessThan", "lessThanInclusive", "greaterThan", "greaterThanInclusive"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"equal",
																									"notEqual",
																									"lessThan",
																									"lessThanInclusive",
																									"greaterThan",
																									"greaterThanInclusive",
																								),
																							},
																						},
																						"params": schema.SingleNestedAttribute{
																							Computed: true,
																							Optional: true,
																							Attributes: map[string]schema.Attribute{
																								"end": schema.Float64Attribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `To where to check`,
																								},
																								"error_message": schema.StringAttribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `Custom error message`,
																								},
																								"start": schema.Float64Attribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `From where to check`,
																								},
																							},
																							Description: `Additional parameters for the condition`,
																						},
																						"value": schema.Float64Attribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Numeric value to compare against. Not Null`,
																							Validators: []validator.Float64{
																								speakeasy_float64validators.NotNull(),
																							},
																						},
																					},
																					Description: `Numeric condition (total-length fact)`,
																					Validators: []validator.Object{
																						objectvalidator.ConflictsWith(path.Expressions{
																							path.MatchRelative().AtParent().AtName("two"),
																							path.MatchRelative().AtParent().AtName("three"),
																							path.MatchRelative().AtParent().AtName("four"),
																						}...),
																					},
																				},
																				"three": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"fact": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `The name of the value to validate. Not Null; must be "static-check"`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"static-check",
																								),
																							},
																						},
																						"operator": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Array-based comparison operator. Not Null; must be one of ["in", "notIn", "contains", "doesNotContain"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"in",
																									"notIn",
																									"contains",
																									"doesNotContain",
																								),
																							},
																						},
																						"params": schema.SingleNestedAttribute{
																							Computed: true,
																							Optional: true,
																							Attributes: map[string]schema.Attribute{
																								"end": schema.Float64Attribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `To where to check`,
																								},
																								"error_message": schema.StringAttribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `Custom error message`,
																								},
																								"start": schema.Float64Attribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `From where to check`,
																								},
																							},
																							Description: `Additional parameters for the condition`,
																						},
																						"value": schema.ListAttribute{
																							Computed:    true,
																							Optional:    true,
																							ElementType: types.StringType,
																							Description: `Array of string values for array-based operators. Not Null`,
																							Validators: []validator.List{
																								speakeasy_listvalidators.NotNull(),
																							},
																						},
																					},
																					Description: `Array-based condition (in, notIn, contains, doesNotContain)`,
																					Validators: []validator.Object{
																						objectvalidator.ConflictsWith(path.Expressions{
																							path.MatchRelative().AtParent().AtName("one"),
																							path.MatchRelative().AtParent().AtName("two"),
																							path.MatchRelative().AtParent().AtName("four"),
																						}...),
																					},
																				},
																				"two": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"fact": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `The name of the value to validate. Not Null; must be one of ["static-check", "total-length"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"static-check",
																									"total-length",
																								),
																							},
																						},
																						"operator": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Exact digit count operator. Not Null; must be "exactlyNDigits"`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"exactlyNDigits",
																								),
																							},
																						},
																						"params": schema.SingleNestedAttribute{
																							Computed: true,
																							Optional: true,
																							Attributes: map[string]schema.Attribute{
																								"end": schema.Float64Attribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `To where to check`,
																								},
																								"error_message": schema.StringAttribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `Custom error message`,
																								},
																								"start": schema.Float64Attribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `From where to check`,
																								},
																							},
																							Description: `Additional parameters for the condition`,
																						},
																						"value": schema.Float64Attribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Number of digits required. Not Null`,
																							Validators: []validator.Float64{
																								speakeasy_float64validators.NotNull(),
																							},
																						},
																					},
																					Description: `Exact digits condition`,
																					Validators: []validator.Object{
																						objectvalidator.ConflictsWith(path.Expressions{
																							path.MatchRelative().AtParent().AtName("one"),
																							path.MatchRelative().AtParent().AtName("three"),
																							path.MatchRelative().AtParent().AtName("four"),
																						}...),
																					},
																				},
																			},
																		},
																		Description: `Not Null`,
																		Validators: []validator.List{
																			speakeasy_listvalidators.NotNull(),
																		},
																	},
																},
																Validators: []validator.Object{
																	objectvalidator.ConflictsWith(path.Expressions{
																		path.MatchRelative().AtParent().AtName("one"),
																		path.MatchRelative().AtParent().AtName("three"),
																	}...),
																},
															},
														},
														Description: `Nested condition with logical operators (level 2 only)`,
														Validators: []validator.Object{
															objectvalidator.ConflictsWith(path.Expressions{
																path.MatchRelative().AtParent().AtName("pattern_fact_condition"),
															}...),
														},
													},
												},
												Description: `Not Null`,
												Validators: []validator.Object{
													speakeasy_objectvalidators.NotNull(),
												},
											},
										},
										Description: `NOT condition (negation)`,
										Validators: []validator.Object{
											objectvalidator.ConflictsWith(path.Expressions{
												path.MatchRelative().AtParent().AtName("one"),
												path.MatchRelative().AtParent().AtName("two"),
											}...),
										},
									},
									"two": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"any": schema.ListNestedAttribute{
												Computed: true,
												Optional: true,
												NestedObject: schema.NestedAttributeObject{
													Validators: []validator.Object{
														speakeasy_objectvalidators.NotNull(),
													},
													Attributes: map[string]schema.Attribute{
														"pattern_fact_condition": schema.SingleNestedAttribute{
															Computed: true,
															Optional: true,
															Attributes: map[string]schema.Attribute{
																"four": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"fact": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `The name of the value to validate. Not Null; must be "static-check"`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																				stringvalidator.OneOf(
																					"static-check",
																				),
																			},
																		},
																		"operator": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `String comparison operator. Not Null; must be one of ["equal", "notEqual"]`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																				stringvalidator.OneOf(
																					"equal",
																					"notEqual",
																				),
																			},
																		},
																		"params": schema.SingleNestedAttribute{
																			Computed: true,
																			Optional: true,
																			Attributes: map[string]schema.Attribute{
																				"end": schema.Float64Attribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `To where to check`,
																				},
																				"error_message": schema.StringAttribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `Custom error message`,
																				},
																				"start": schema.Float64Attribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `From where to check`,
																				},
																			},
																			Description: `Additional parameters for the condition`,
																		},
																		"value": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `String value to compare against. Not Null`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																			},
																		},
																	},
																	Description: `String-based condition`,
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("one"),
																			path.MatchRelative().AtParent().AtName("two"),
																			path.MatchRelative().AtParent().AtName("three"),
																		}...),
																	},
																},
																"one": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"fact": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `The name of the value to validate. Not Null; must be "total-length"`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																				stringvalidator.OneOf(
																					"total-length",
																				),
																			},
																		},
																		"operator": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Numeric comparison operator. Not Null; must be one of ["equal", "notEqual", "lessThan", "lessThanInclusive", "greaterThan", "greaterThanInclusive"]`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																				stringvalidator.OneOf(
																					"equal",
																					"notEqual",
																					"lessThan",
																					"lessThanInclusive",
																					"greaterThan",
																					"greaterThanInclusive",
																				),
																			},
																		},
																		"params": schema.SingleNestedAttribute{
																			Computed: true,
																			Optional: true,
																			Attributes: map[string]schema.Attribute{
																				"end": schema.Float64Attribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `To where to check`,
																				},
																				"error_message": schema.StringAttribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `Custom error message`,
																				},
																				"start": schema.Float64Attribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `From where to check`,
																				},
																			},
																			Description: `Additional parameters for the condition`,
																		},
																		"value": schema.Float64Attribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Numeric value to compare against. Not Null`,
																			Validators: []validator.Float64{
																				speakeasy_float64validators.NotNull(),
																			},
																		},
																	},
																	Description: `Numeric condition (total-length fact)`,
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("two"),
																			path.MatchRelative().AtParent().AtName("three"),
																			path.MatchRelative().AtParent().AtName("four"),
																		}...),
																	},
																},
																"three": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"fact": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `The name of the value to validate. Not Null; must be "static-check"`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																				stringvalidator.OneOf(
																					"static-check",
																				),
																			},
																		},
																		"operator": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Array-based comparison operator. Not Null; must be one of ["in", "notIn", "contains", "doesNotContain"]`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																				stringvalidator.OneOf(
																					"in",
																					"notIn",
																					"contains",
																					"doesNotContain",
																				),
																			},
																		},
																		"params": schema.SingleNestedAttribute{
																			Computed: true,
																			Optional: true,
																			Attributes: map[string]schema.Attribute{
																				"end": schema.Float64Attribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `To where to check`,
																				},
																				"error_message": schema.StringAttribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `Custom error message`,
																				},
																				"start": schema.Float64Attribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `From where to check`,
																				},
																			},
																			Description: `Additional parameters for the condition`,
																		},
																		"value": schema.ListAttribute{
																			Computed:    true,
																			Optional:    true,
																			ElementType: types.StringType,
																			Description: `Array of string values for array-based operators. Not Null`,
																			Validators: []validator.List{
																				speakeasy_listvalidators.NotNull(),
																			},
																		},
																	},
																	Description: `Array-based condition (in, notIn, contains, doesNotContain)`,
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("one"),
																			path.MatchRelative().AtParent().AtName("two"),
																			path.MatchRelative().AtParent().AtName("four"),
																		}...),
																	},
																},
																"two": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"fact": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `The name of the value to validate. Not Null; must be one of ["static-check", "total-length"]`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																				stringvalidator.OneOf(
																					"static-check",
																					"total-length",
																				),
																			},
																		},
																		"operator": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Exact digit count operator. Not Null; must be "exactlyNDigits"`,
																			Validators: []validator.String{
																				speakeasy_stringvalidators.NotNull(),
																				stringvalidator.OneOf(
																					"exactlyNDigits",
																				),
																			},
																		},
																		"params": schema.SingleNestedAttribute{
																			Computed: true,
																			Optional: true,
																			Attributes: map[string]schema.Attribute{
																				"end": schema.Float64Attribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `To where to check`,
																				},
																				"error_message": schema.StringAttribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `Custom error message`,
																				},
																				"start": schema.Float64Attribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `From where to check`,
																				},
																			},
																			Description: `Additional parameters for the condition`,
																		},
																		"value": schema.Float64Attribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Number of digits required. Not Null`,
																			Validators: []validator.Float64{
																				speakeasy_float64validators.NotNull(),
																			},
																		},
																	},
																	Description: `Exact digits condition`,
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("one"),
																			path.MatchRelative().AtParent().AtName("three"),
																			path.MatchRelative().AtParent().AtName("four"),
																		}...),
																	},
																},
															},
															Description: `Fact-based condition for pattern validation`,
															Validators: []validator.Object{
																objectvalidator.ConflictsWith(path.Expressions{
																	path.MatchRelative().AtParent().AtName("pattern_nested_condition"),
																}...),
															},
														},
														"pattern_nested_condition": schema.SingleNestedAttribute{
															Computed: true,
															Optional: true,
															Attributes: map[string]schema.Attribute{
																"one": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"all": schema.ListNestedAttribute{
																			Computed: true,
																			Optional: true,
																			NestedObject: schema.NestedAttributeObject{
																				Validators: []validator.Object{
																					speakeasy_objectvalidators.NotNull(),
																				},
																				Attributes: map[string]schema.Attribute{
																					"four": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"fact": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `The name of the value to validate. Not Null; must be "static-check"`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"static-check",
																									),
																								},
																							},
																							"operator": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `String comparison operator. Not Null; must be one of ["equal", "notEqual"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"equal",
																										"notEqual",
																									),
																								},
																							},
																							"params": schema.SingleNestedAttribute{
																								Computed: true,
																								Optional: true,
																								Attributes: map[string]schema.Attribute{
																									"end": schema.Float64Attribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `To where to check`,
																									},
																									"error_message": schema.StringAttribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `Custom error message`,
																									},
																									"start": schema.Float64Attribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `From where to check`,
																									},
																								},
																								Description: `Additional parameters for the condition`,
																							},
																							"value": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `String value to compare against. Not Null`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																								},
																							},
																						},
																						Description: `String-based condition`,
																						Validators: []validator.Object{
																							objectvalidator.ConflictsWith(path.Expressions{
																								path.MatchRelative().AtParent().AtName("one"),
																								path.MatchRelative().AtParent().AtName("two"),
																								path.MatchRelative().AtParent().AtName("three"),
																							}...),
																						},
																					},
																					"one": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"fact": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `The name of the value to validate. Not Null; must be "total-length"`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"total-length",
																									),
																								},
																							},
																							"operator": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Numeric comparison operator. Not Null; must be one of ["equal", "notEqual", "lessThan", "lessThanInclusive", "greaterThan", "greaterThanInclusive"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"equal",
																										"notEqual",
																										"lessThan",
																										"lessThanInclusive",
																										"greaterThan",
																										"greaterThanInclusive",
																									),
																								},
																							},
																							"params": schema.SingleNestedAttribute{
																								Computed: true,
																								Optional: true,
																								Attributes: map[string]schema.Attribute{
																									"end": schema.Float64Attribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `To where to check`,
																									},
																									"error_message": schema.StringAttribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `Custom error message`,
																									},
																									"start": schema.Float64Attribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `From where to check`,
																									},
																								},
																								Description: `Additional parameters for the condition`,
																							},
																							"value": schema.Float64Attribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Numeric value to compare against. Not Null`,
																								Validators: []validator.Float64{
																									speakeasy_float64validators.NotNull(),
																								},
																							},
																						},
																						Description: `Numeric condition (total-length fact)`,
																						Validators: []validator.Object{
																							objectvalidator.ConflictsWith(path.Expressions{
																								path.MatchRelative().AtParent().AtName("two"),
																								path.MatchRelative().AtParent().AtName("three"),
																								path.MatchRelative().AtParent().AtName("four"),
																							}...),
																						},
																					},
																					"three": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"fact": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `The name of the value to validate. Not Null; must be "static-check"`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"static-check",
																									),
																								},
																							},
																							"operator": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Array-based comparison operator. Not Null; must be one of ["in", "notIn", "contains", "doesNotContain"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"in",
																										"notIn",
																										"contains",
																										"doesNotContain",
																									),
																								},
																							},
																							"params": schema.SingleNestedAttribute{
																								Computed: true,
																								Optional: true,
																								Attributes: map[string]schema.Attribute{
																									"end": schema.Float64Attribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `To where to check`,
																									},
																									"error_message": schema.StringAttribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `Custom error message`,
																									},
																									"start": schema.Float64Attribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `From where to check`,
																									},
																								},
																								Description: `Additional parameters for the condition`,
																							},
																							"value": schema.ListAttribute{
																								Computed:    true,
																								Optional:    true,
																								ElementType: types.StringType,
																								Description: `Array of string values for array-based operators. Not Null`,
																								Validators: []validator.List{
																									speakeasy_listvalidators.NotNull(),
																								},
																							},
																						},
																						Description: `Array-based condition (in, notIn, contains, doesNotContain)`,
																						Validators: []validator.Object{
																							objectvalidator.ConflictsWith(path.Expressions{
																								path.MatchRelative().AtParent().AtName("one"),
																								path.MatchRelative().AtParent().AtName("two"),
																								path.MatchRelative().AtParent().AtName("four"),
																							}...),
																						},
																					},
																					"two": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"fact": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `The name of the value to validate. Not Null; must be one of ["static-check", "total-length"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"static-check",
																										"total-length",
																									),
																								},
																							},
																							"operator": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Exact digit count operator. Not Null; must be "exactlyNDigits"`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"exactlyNDigits",
																									),
																								},
																							},
																							"params": schema.SingleNestedAttribute{
																								Computed: true,
																								Optional: true,
																								Attributes: map[string]schema.Attribute{
																									"end": schema.Float64Attribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `To where to check`,
																									},
																									"error_message": schema.StringAttribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `Custom error message`,
																									},
																									"start": schema.Float64Attribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `From where to check`,
																									},
																								},
																								Description: `Additional parameters for the condition`,
																							},
																							"value": schema.Float64Attribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Number of digits required. Not Null`,
																								Validators: []validator.Float64{
																									speakeasy_float64validators.NotNull(),
																								},
																							},
																						},
																						Description: `Exact digits condition`,
																						Validators: []validator.Object{
																							objectvalidator.ConflictsWith(path.Expressions{
																								path.MatchRelative().AtParent().AtName("one"),
																								path.MatchRelative().AtParent().AtName("three"),
																								path.MatchRelative().AtParent().AtName("four"),
																							}...),
																						},
																					},
																				},
																			},
																			Description: `Not Null`,
																			Validators: []validator.List{
																				speakeasy_listvalidators.NotNull(),
																			},
																		},
																	},
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("two"),
																			path.MatchRelative().AtParent().AtName("three"),
																		}...),
																	},
																},
																"three": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"not": schema.SingleNestedAttribute{
																			Computed: true,
																			Optional: true,
																			Attributes: map[string]schema.Attribute{
																				"four": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"fact": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `The name of the value to validate. Not Null; must be "static-check"`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"static-check",
																								),
																							},
																						},
																						"operator": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `String comparison operator. Not Null; must be one of ["equal", "notEqual"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"equal",
																									"notEqual",
																								),
																							},
																						},
																						"params": schema.SingleNestedAttribute{
																							Computed: true,
																							Optional: true,
																							Attributes: map[string]schema.Attribute{
																								"end": schema.Float64Attribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `To where to check`,
																								},
																								"error_message": schema.StringAttribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `Custom error message`,
																								},
																								"start": schema.Float64Attribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `From where to check`,
																								},
																							},
																							Description: `Additional parameters for the condition`,
																						},
																						"value": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `String value to compare against. Not Null`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																							},
																						},
																					},
																					Description: `String-based condition`,
																					Validators: []validator.Object{
																						objectvalidator.ConflictsWith(path.Expressions{
																							path.MatchRelative().AtParent().AtName("one"),
																							path.MatchRelative().AtParent().AtName("two"),
																							path.MatchRelative().AtParent().AtName("three"),
																						}...),
																					},
																				},
																				"one": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"fact": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `The name of the value to validate. Not Null; must be "total-length"`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"total-length",
																								),
																							},
																						},
																						"operator": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Numeric comparison operator. Not Null; must be one of ["equal", "notEqual", "lessThan", "lessThanInclusive", "greaterThan", "greaterThanInclusive"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"equal",
																									"notEqual",
																									"lessThan",
																									"lessThanInclusive",
																									"greaterThan",
																									"greaterThanInclusive",
																								),
																							},
																						},
																						"params": schema.SingleNestedAttribute{
																							Computed: true,
																							Optional: true,
																							Attributes: map[string]schema.Attribute{
																								"end": schema.Float64Attribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `To where to check`,
																								},
																								"error_message": schema.StringAttribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `Custom error message`,
																								},
																								"start": schema.Float64Attribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `From where to check`,
																								},
																							},
																							Description: `Additional parameters for the condition`,
																						},
																						"value": schema.Float64Attribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Numeric value to compare against. Not Null`,
																							Validators: []validator.Float64{
																								speakeasy_float64validators.NotNull(),
																							},
																						},
																					},
																					Description: `Numeric condition (total-length fact)`,
																					Validators: []validator.Object{
																						objectvalidator.ConflictsWith(path.Expressions{
																							path.MatchRelative().AtParent().AtName("two"),
																							path.MatchRelative().AtParent().AtName("three"),
																							path.MatchRelative().AtParent().AtName("four"),
																						}...),
																					},
																				},
																				"three": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"fact": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `The name of the value to validate. Not Null; must be "static-check"`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"static-check",
																								),
																							},
																						},
																						"operator": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Array-based comparison operator. Not Null; must be one of ["in", "notIn", "contains", "doesNotContain"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"in",
																									"notIn",
																									"contains",
																									"doesNotContain",
																								),
																							},
																						},
																						"params": schema.SingleNestedAttribute{
																							Computed: true,
																							Optional: true,
																							Attributes: map[string]schema.Attribute{
																								"end": schema.Float64Attribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `To where to check`,
																								},
																								"error_message": schema.StringAttribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `Custom error message`,
																								},
																								"start": schema.Float64Attribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `From where to check`,
																								},
																							},
																							Description: `Additional parameters for the condition`,
																						},
																						"value": schema.ListAttribute{
																							Computed:    true,
																							Optional:    true,
																							ElementType: types.StringType,
																							Description: `Array of string values for array-based operators. Not Null`,
																							Validators: []validator.List{
																								speakeasy_listvalidators.NotNull(),
																							},
																						},
																					},
																					Description: `Array-based condition (in, notIn, contains, doesNotContain)`,
																					Validators: []validator.Object{
																						objectvalidator.ConflictsWith(path.Expressions{
																							path.MatchRelative().AtParent().AtName("one"),
																							path.MatchRelative().AtParent().AtName("two"),
																							path.MatchRelative().AtParent().AtName("four"),
																						}...),
																					},
																				},
																				"two": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"fact": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `The name of the value to validate. Not Null; must be one of ["static-check", "total-length"]`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"static-check",
																									"total-length",
																								),
																							},
																						},
																						"operator": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Exact digit count operator. Not Null; must be "exactlyNDigits"`,
																							Validators: []validator.String{
																								speakeasy_stringvalidators.NotNull(),
																								stringvalidator.OneOf(
																									"exactlyNDigits",
																								),
																							},
																						},
																						"params": schema.SingleNestedAttribute{
																							Computed: true,
																							Optional: true,
																							Attributes: map[string]schema.Attribute{
																								"end": schema.Float64Attribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `To where to check`,
																								},
																								"error_message": schema.StringAttribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `Custom error message`,
																								},
																								"start": schema.Float64Attribute{
																									Computed:    true,
																									Optional:    true,
																									Description: `From where to check`,
																								},
																							},
																							Description: `Additional parameters for the condition`,
																						},
																						"value": schema.Float64Attribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Number of digits required. Not Null`,
																							Validators: []validator.Float64{
																								speakeasy_float64validators.NotNull(),
																							},
																						},
																					},
																					Description: `Exact digits condition`,
																					Validators: []validator.Object{
																						objectvalidator.ConflictsWith(path.Expressions{
																							path.MatchRelative().AtParent().AtName("one"),
																							path.MatchRelative().AtParent().AtName("three"),
																							path.MatchRelative().AtParent().AtName("four"),
																						}...),
																					},
																				},
																			},
																			Description: `Fact-based condition for pattern validation. Not Null`,
																			Validators: []validator.Object{
																				speakeasy_objectvalidators.NotNull(),
																			},
																		},
																	},
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("one"),
																			path.MatchRelative().AtParent().AtName("two"),
																		}...),
																	},
																},
																"two": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"any": schema.ListNestedAttribute{
																			Computed: true,
																			Optional: true,
																			NestedObject: schema.NestedAttributeObject{
																				Validators: []validator.Object{
																					speakeasy_objectvalidators.NotNull(),
																				},
																				Attributes: map[string]schema.Attribute{
																					"four": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"fact": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `The name of the value to validate. Not Null; must be "static-check"`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"static-check",
																									),
																								},
																							},
																							"operator": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `String comparison operator. Not Null; must be one of ["equal", "notEqual"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"equal",
																										"notEqual",
																									),
																								},
																							},
																							"params": schema.SingleNestedAttribute{
																								Computed: true,
																								Optional: true,
																								Attributes: map[string]schema.Attribute{
																									"end": schema.Float64Attribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `To where to check`,
																									},
																									"error_message": schema.StringAttribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `Custom error message`,
																									},
																									"start": schema.Float64Attribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `From where to check`,
																									},
																								},
																								Description: `Additional parameters for the condition`,
																							},
																							"value": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `String value to compare against. Not Null`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																								},
																							},
																						},
																						Description: `String-based condition`,
																						Validators: []validator.Object{
																							objectvalidator.ConflictsWith(path.Expressions{
																								path.MatchRelative().AtParent().AtName("one"),
																								path.MatchRelative().AtParent().AtName("two"),
																								path.MatchRelative().AtParent().AtName("three"),
																							}...),
																						},
																					},
																					"one": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"fact": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `The name of the value to validate. Not Null; must be "total-length"`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"total-length",
																									),
																								},
																							},
																							"operator": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Numeric comparison operator. Not Null; must be one of ["equal", "notEqual", "lessThan", "lessThanInclusive", "greaterThan", "greaterThanInclusive"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"equal",
																										"notEqual",
																										"lessThan",
																										"lessThanInclusive",
																										"greaterThan",
																										"greaterThanInclusive",
																									),
																								},
																							},
																							"params": schema.SingleNestedAttribute{
																								Computed: true,
																								Optional: true,
																								Attributes: map[string]schema.Attribute{
																									"end": schema.Float64Attribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `To where to check`,
																									},
																									"error_message": schema.StringAttribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `Custom error message`,
																									},
																									"start": schema.Float64Attribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `From where to check`,
																									},
																								},
																								Description: `Additional parameters for the condition`,
																							},
																							"value": schema.Float64Attribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Numeric value to compare against. Not Null`,
																								Validators: []validator.Float64{
																									speakeasy_float64validators.NotNull(),
																								},
																							},
																						},
																						Description: `Numeric condition (total-length fact)`,
																						Validators: []validator.Object{
																							objectvalidator.ConflictsWith(path.Expressions{
																								path.MatchRelative().AtParent().AtName("two"),
																								path.MatchRelative().AtParent().AtName("three"),
																								path.MatchRelative().AtParent().AtName("four"),
																							}...),
																						},
																					},
																					"three": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"fact": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `The name of the value to validate. Not Null; must be "static-check"`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"static-check",
																									),
																								},
																							},
																							"operator": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Array-based comparison operator. Not Null; must be one of ["in", "notIn", "contains", "doesNotContain"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"in",
																										"notIn",
																										"contains",
																										"doesNotContain",
																									),
																								},
																							},
																							"params": schema.SingleNestedAttribute{
																								Computed: true,
																								Optional: true,
																								Attributes: map[string]schema.Attribute{
																									"end": schema.Float64Attribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `To where to check`,
																									},
																									"error_message": schema.StringAttribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `Custom error message`,
																									},
																									"start": schema.Float64Attribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `From where to check`,
																									},
																								},
																								Description: `Additional parameters for the condition`,
																							},
																							"value": schema.ListAttribute{
																								Computed:    true,
																								Optional:    true,
																								ElementType: types.StringType,
																								Description: `Array of string values for array-based operators. Not Null`,
																								Validators: []validator.List{
																									speakeasy_listvalidators.NotNull(),
																								},
																							},
																						},
																						Description: `Array-based condition (in, notIn, contains, doesNotContain)`,
																						Validators: []validator.Object{
																							objectvalidator.ConflictsWith(path.Expressions{
																								path.MatchRelative().AtParent().AtName("one"),
																								path.MatchRelative().AtParent().AtName("two"),
																								path.MatchRelative().AtParent().AtName("four"),
																							}...),
																						},
																					},
																					"two": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"fact": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `The name of the value to validate. Not Null; must be one of ["static-check", "total-length"]`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"static-check",
																										"total-length",
																									),
																								},
																							},
																							"operator": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Exact digit count operator. Not Null; must be "exactlyNDigits"`,
																								Validators: []validator.String{
																									speakeasy_stringvalidators.NotNull(),
																									stringvalidator.OneOf(
																										"exactlyNDigits",
																									),
																								},
																							},
																							"params": schema.SingleNestedAttribute{
																								Computed: true,
																								Optional: true,
																								Attributes: map[string]schema.Attribute{
																									"end": schema.Float64Attribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `To where to check`,
																									},
																									"error_message": schema.StringAttribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `Custom error message`,
																									},
																									"start": schema.Float64Attribute{
																										Computed:    true,
																										Optional:    true,
																										Description: `From where to check`,
																									},
																								},
																								Description: `Additional parameters for the condition`,
																							},
																							"value": schema.Float64Attribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Number of digits required. Not Null`,
																								Validators: []validator.Float64{
																									speakeasy_float64validators.NotNull(),
																								},
																							},
																						},
																						Description: `Exact digits condition`,
																						Validators: []validator.Object{
																							objectvalidator.ConflictsWith(path.Expressions{
																								path.MatchRelative().AtParent().AtName("one"),
																								path.MatchRelative().AtParent().AtName("three"),
																								path.MatchRelative().AtParent().AtName("four"),
																							}...),
																						},
																					},
																				},
																			},
																			Description: `Not Null`,
																			Validators: []validator.List{
																				speakeasy_listvalidators.NotNull(),
																			},
																		},
																	},
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("one"),
																			path.MatchRelative().AtParent().AtName("three"),
																		}...),
																	},
																},
															},
															Description: `Nested condition with logical operators (level 2 only)`,
															Validators: []validator.Object{
																objectvalidator.ConflictsWith(path.Expressions{
																	path.MatchRelative().AtParent().AtName("pattern_fact_condition"),
																}...),
															},
														},
													},
												},
												Description: `Not Null`,
												Validators: []validator.List{
													speakeasy_listvalidators.NotNull(),
												},
											},
										},
										Description: `Any conditions must be true (OR logic)`,
										Validators: []validator.Object{
											objectvalidator.ConflictsWith(path.Expressions{
												path.MatchRelative().AtParent().AtName("one"),
												path.MatchRelative().AtParent().AtName("three"),
											}...),
										},
									},
								},
								Description: `Condition definition for a pattern-based validation rule (2 levels deep). Not Null`,
								Validators: []validator.Object{
									speakeasy_objectvalidators.NotNull(),
								},
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Description: `Indicates this is a pattern-based validation rule. Not Null; must be "pattern"`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf("pattern"),
								},
							},
						},
						Description: `Validation rule that uses a sequence of patterns to validate input.`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("numeric_rule_type"),
								path.MatchRelative().AtParent().AtName("regex_rule_type"),
							}...),
						},
					},
					"regex_rule_type": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"conditions": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"one": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"all": schema.ListNestedAttribute{
												Computed: true,
												Optional: true,
												NestedObject: schema.NestedAttributeObject{
													Validators: []validator.Object{
														speakeasy_objectvalidators.NotNull(),
													},
													Attributes: map[string]schema.Attribute{
														"regex_fact_condition": schema.SingleNestedAttribute{
															Computed: true,
															Optional: true,
															Attributes: map[string]schema.Attribute{
																"fact": schema.StringAttribute{
																	Computed:    true,
																	Optional:    true,
																	Description: `The name of the value to validate. Should always be 'inputValue' because this property name is passed to the engine. Not Null; must be "inputValue"`,
																	Validators: []validator.String{
																		speakeasy_stringvalidators.NotNull(),
																		stringvalidator.OneOf(
																			"inputValue",
																		),
																	},
																},
																"operator": schema.StringAttribute{
																	Computed:    true,
																	Optional:    true,
																	Description: `The operator to use for comparison. Not Null; must be "regexMatch"`,
																	Validators: []validator.String{
																		speakeasy_stringvalidators.NotNull(),
																		stringvalidator.OneOf(
																			"regexMatch",
																		),
																	},
																},
																"params": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"error_message": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Custom error message`,
																		},
																	},
																	Description: `Additional parameters for the condition`,
																},
																"value": schema.StringAttribute{
																	Computed:    true,
																	Optional:    true,
																	Description: `The actual regex. Not Null`,
																	Validators: []validator.String{
																		speakeasy_stringvalidators.NotNull(),
																	},
																},
															},
															Description: `Fact-based condition for regex validation`,
															Validators: []validator.Object{
																objectvalidator.ConflictsWith(path.Expressions{
																	path.MatchRelative().AtParent().AtName("regex_nested_condition"),
																}...),
															},
														},
														"regex_nested_condition": schema.SingleNestedAttribute{
															Computed: true,
															Optional: true,
															Attributes: map[string]schema.Attribute{
																"one": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"all": schema.ListNestedAttribute{
																			Computed: true,
																			Optional: true,
																			NestedObject: schema.NestedAttributeObject{
																				Validators: []validator.Object{
																					speakeasy_objectvalidators.NotNull(),
																				},
																				Attributes: map[string]schema.Attribute{
																					"fact": schema.StringAttribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `The name of the value to validate. Should always be 'inputValue' because this property name is passed to the engine. Not Null; must be "inputValue"`,
																						Validators: []validator.String{
																							speakeasy_stringvalidators.NotNull(),
																							stringvalidator.OneOf(
																								"inputValue",
																							),
																						},
																					},
																					"operator": schema.StringAttribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `The operator to use for comparison. Not Null; must be "regexMatch"`,
																						Validators: []validator.String{
																							speakeasy_stringvalidators.NotNull(),
																							stringvalidator.OneOf(
																								"regexMatch",
																							),
																						},
																					},
																					"params": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"error_message": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Custom error message`,
																							},
																						},
																						Description: `Additional parameters for the condition`,
																					},
																					"value": schema.StringAttribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `The actual regex. Not Null`,
																						Validators: []validator.String{
																							speakeasy_stringvalidators.NotNull(),
																						},
																					},
																				},
																			},
																			Description: `Not Null`,
																			Validators: []validator.List{
																				speakeasy_listvalidators.NotNull(),
																			},
																		},
																	},
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("two"),
																			path.MatchRelative().AtParent().AtName("three"),
																		}...),
																	},
																},
																"three": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"not": schema.SingleNestedAttribute{
																			Computed: true,
																			Optional: true,
																			Attributes: map[string]schema.Attribute{
																				"fact": schema.StringAttribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `The name of the value to validate. Should always be 'inputValue' because this property name is passed to the engine. Not Null; must be "inputValue"`,
																					Validators: []validator.String{
																						speakeasy_stringvalidators.NotNull(),
																						stringvalidator.OneOf(
																							"inputValue",
																						),
																					},
																				},
																				"operator": schema.StringAttribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `The operator to use for comparison. Not Null; must be "regexMatch"`,
																					Validators: []validator.String{
																						speakeasy_stringvalidators.NotNull(),
																						stringvalidator.OneOf(
																							"regexMatch",
																						),
																					},
																				},
																				"params": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"error_message": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Custom error message`,
																						},
																					},
																					Description: `Additional parameters for the condition`,
																				},
																				"value": schema.StringAttribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `The actual regex. Not Null`,
																					Validators: []validator.String{
																						speakeasy_stringvalidators.NotNull(),
																					},
																				},
																			},
																			Description: `Fact-based condition for regex validation. Not Null`,
																			Validators: []validator.Object{
																				speakeasy_objectvalidators.NotNull(),
																			},
																		},
																	},
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("one"),
																			path.MatchRelative().AtParent().AtName("two"),
																		}...),
																	},
																},
																"two": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"any": schema.ListNestedAttribute{
																			Computed: true,
																			Optional: true,
																			NestedObject: schema.NestedAttributeObject{
																				Validators: []validator.Object{
																					speakeasy_objectvalidators.NotNull(),
																				},
																				Attributes: map[string]schema.Attribute{
																					"fact": schema.StringAttribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `The name of the value to validate. Should always be 'inputValue' because this property name is passed to the engine. Not Null; must be "inputValue"`,
																						Validators: []validator.String{
																							speakeasy_stringvalidators.NotNull(),
																							stringvalidator.OneOf(
																								"inputValue",
																							),
																						},
																					},
																					"operator": schema.StringAttribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `The operator to use for comparison. Not Null; must be "regexMatch"`,
																						Validators: []validator.String{
																							speakeasy_stringvalidators.NotNull(),
																							stringvalidator.OneOf(
																								"regexMatch",
																							),
																						},
																					},
																					"params": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"error_message": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Custom error message`,
																							},
																						},
																						Description: `Additional parameters for the condition`,
																					},
																					"value": schema.StringAttribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `The actual regex. Not Null`,
																						Validators: []validator.String{
																							speakeasy_stringvalidators.NotNull(),
																						},
																					},
																				},
																			},
																			Description: `Not Null`,
																			Validators: []validator.List{
																				speakeasy_listvalidators.NotNull(),
																			},
																		},
																	},
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("one"),
																			path.MatchRelative().AtParent().AtName("three"),
																		}...),
																	},
																},
															},
															Description: `Nested condition with logical operators (level 2 only)`,
															Validators: []validator.Object{
																objectvalidator.ConflictsWith(path.Expressions{
																	path.MatchRelative().AtParent().AtName("regex_fact_condition"),
																}...),
															},
														},
													},
												},
												Description: `Not Null`,
												Validators: []validator.List{
													speakeasy_listvalidators.NotNull(),
												},
											},
										},
										Description: `All conditions must be true (AND logic)`,
										Validators: []validator.Object{
											objectvalidator.ConflictsWith(path.Expressions{
												path.MatchRelative().AtParent().AtName("two"),
												path.MatchRelative().AtParent().AtName("three"),
											}...),
										},
									},
									"three": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"not": schema.SingleNestedAttribute{
												Computed: true,
												Optional: true,
												Attributes: map[string]schema.Attribute{
													"regex_fact_condition": schema.SingleNestedAttribute{
														Computed: true,
														Optional: true,
														Attributes: map[string]schema.Attribute{
															"fact": schema.StringAttribute{
																Computed:    true,
																Optional:    true,
																Description: `The name of the value to validate. Should always be 'inputValue' because this property name is passed to the engine. Not Null; must be "inputValue"`,
																Validators: []validator.String{
																	speakeasy_stringvalidators.NotNull(),
																	stringvalidator.OneOf(
																		"inputValue",
																	),
																},
															},
															"operator": schema.StringAttribute{
																Computed:    true,
																Optional:    true,
																Description: `The operator to use for comparison. Not Null; must be "regexMatch"`,
																Validators: []validator.String{
																	speakeasy_stringvalidators.NotNull(),
																	stringvalidator.OneOf(
																		"regexMatch",
																	),
																},
															},
															"params": schema.SingleNestedAttribute{
																Computed: true,
																Optional: true,
																Attributes: map[string]schema.Attribute{
																	"error_message": schema.StringAttribute{
																		Computed:    true,
																		Optional:    true,
																		Description: `Custom error message`,
																	},
																},
																Description: `Additional parameters for the condition`,
															},
															"value": schema.StringAttribute{
																Computed:    true,
																Optional:    true,
																Description: `The actual regex. Not Null`,
																Validators: []validator.String{
																	speakeasy_stringvalidators.NotNull(),
																},
															},
														},
														Description: `Fact-based condition for regex validation`,
														Validators: []validator.Object{
															objectvalidator.ConflictsWith(path.Expressions{
																path.MatchRelative().AtParent().AtName("regex_nested_condition"),
															}...),
														},
													},
													"regex_nested_condition": schema.SingleNestedAttribute{
														Computed: true,
														Optional: true,
														Attributes: map[string]schema.Attribute{
															"one": schema.SingleNestedAttribute{
																Computed: true,
																Optional: true,
																Attributes: map[string]schema.Attribute{
																	"all": schema.ListNestedAttribute{
																		Computed: true,
																		Optional: true,
																		NestedObject: schema.NestedAttributeObject{
																			Validators: []validator.Object{
																				speakeasy_objectvalidators.NotNull(),
																			},
																			Attributes: map[string]schema.Attribute{
																				"fact": schema.StringAttribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `The name of the value to validate. Should always be 'inputValue' because this property name is passed to the engine. Not Null; must be "inputValue"`,
																					Validators: []validator.String{
																						speakeasy_stringvalidators.NotNull(),
																						stringvalidator.OneOf(
																							"inputValue",
																						),
																					},
																				},
																				"operator": schema.StringAttribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `The operator to use for comparison. Not Null; must be "regexMatch"`,
																					Validators: []validator.String{
																						speakeasy_stringvalidators.NotNull(),
																						stringvalidator.OneOf(
																							"regexMatch",
																						),
																					},
																				},
																				"params": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"error_message": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Custom error message`,
																						},
																					},
																					Description: `Additional parameters for the condition`,
																				},
																				"value": schema.StringAttribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `The actual regex. Not Null`,
																					Validators: []validator.String{
																						speakeasy_stringvalidators.NotNull(),
																					},
																				},
																			},
																		},
																		Description: `Not Null`,
																		Validators: []validator.List{
																			speakeasy_listvalidators.NotNull(),
																		},
																	},
																},
																Validators: []validator.Object{
																	objectvalidator.ConflictsWith(path.Expressions{
																		path.MatchRelative().AtParent().AtName("two"),
																		path.MatchRelative().AtParent().AtName("three"),
																	}...),
																},
															},
															"three": schema.SingleNestedAttribute{
																Computed: true,
																Optional: true,
																Attributes: map[string]schema.Attribute{
																	"not": schema.SingleNestedAttribute{
																		Computed: true,
																		Optional: true,
																		Attributes: map[string]schema.Attribute{
																			"fact": schema.StringAttribute{
																				Computed:    true,
																				Optional:    true,
																				Description: `The name of the value to validate. Should always be 'inputValue' because this property name is passed to the engine. Not Null; must be "inputValue"`,
																				Validators: []validator.String{
																					speakeasy_stringvalidators.NotNull(),
																					stringvalidator.OneOf(
																						"inputValue",
																					),
																				},
																			},
																			"operator": schema.StringAttribute{
																				Computed:    true,
																				Optional:    true,
																				Description: `The operator to use for comparison. Not Null; must be "regexMatch"`,
																				Validators: []validator.String{
																					speakeasy_stringvalidators.NotNull(),
																					stringvalidator.OneOf(
																						"regexMatch",
																					),
																				},
																			},
																			"params": schema.SingleNestedAttribute{
																				Computed: true,
																				Optional: true,
																				Attributes: map[string]schema.Attribute{
																					"error_message": schema.StringAttribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `Custom error message`,
																					},
																				},
																				Description: `Additional parameters for the condition`,
																			},
																			"value": schema.StringAttribute{
																				Computed:    true,
																				Optional:    true,
																				Description: `The actual regex. Not Null`,
																				Validators: []validator.String{
																					speakeasy_stringvalidators.NotNull(),
																				},
																			},
																		},
																		Description: `Fact-based condition for regex validation. Not Null`,
																		Validators: []validator.Object{
																			speakeasy_objectvalidators.NotNull(),
																		},
																	},
																},
																Validators: []validator.Object{
																	objectvalidator.ConflictsWith(path.Expressions{
																		path.MatchRelative().AtParent().AtName("one"),
																		path.MatchRelative().AtParent().AtName("two"),
																	}...),
																},
															},
															"two": schema.SingleNestedAttribute{
																Computed: true,
																Optional: true,
																Attributes: map[string]schema.Attribute{
																	"any": schema.ListNestedAttribute{
																		Computed: true,
																		Optional: true,
																		NestedObject: schema.NestedAttributeObject{
																			Validators: []validator.Object{
																				speakeasy_objectvalidators.NotNull(),
																			},
																			Attributes: map[string]schema.Attribute{
																				"fact": schema.StringAttribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `The name of the value to validate. Should always be 'inputValue' because this property name is passed to the engine. Not Null; must be "inputValue"`,
																					Validators: []validator.String{
																						speakeasy_stringvalidators.NotNull(),
																						stringvalidator.OneOf(
																							"inputValue",
																						),
																					},
																				},
																				"operator": schema.StringAttribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `The operator to use for comparison. Not Null; must be "regexMatch"`,
																					Validators: []validator.String{
																						speakeasy_stringvalidators.NotNull(),
																						stringvalidator.OneOf(
																							"regexMatch",
																						),
																					},
																				},
																				"params": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"error_message": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Custom error message`,
																						},
																					},
																					Description: `Additional parameters for the condition`,
																				},
																				"value": schema.StringAttribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `The actual regex. Not Null`,
																					Validators: []validator.String{
																						speakeasy_stringvalidators.NotNull(),
																					},
																				},
																			},
																		},
																		Description: `Not Null`,
																		Validators: []validator.List{
																			speakeasy_listvalidators.NotNull(),
																		},
																	},
																},
																Validators: []validator.Object{
																	objectvalidator.ConflictsWith(path.Expressions{
																		path.MatchRelative().AtParent().AtName("one"),
																		path.MatchRelative().AtParent().AtName("three"),
																	}...),
																},
															},
														},
														Description: `Nested condition with logical operators (level 2 only)`,
														Validators: []validator.Object{
															objectvalidator.ConflictsWith(path.Expressions{
																path.MatchRelative().AtParent().AtName("regex_fact_condition"),
															}...),
														},
													},
												},
												Description: `Not Null`,
												Validators: []validator.Object{
													speakeasy_objectvalidators.NotNull(),
												},
											},
										},
										Description: `NOT condition (negation)`,
										Validators: []validator.Object{
											objectvalidator.ConflictsWith(path.Expressions{
												path.MatchRelative().AtParent().AtName("one"),
												path.MatchRelative().AtParent().AtName("two"),
											}...),
										},
									},
									"two": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"any": schema.ListNestedAttribute{
												Computed: true,
												Optional: true,
												NestedObject: schema.NestedAttributeObject{
													Validators: []validator.Object{
														speakeasy_objectvalidators.NotNull(),
													},
													Attributes: map[string]schema.Attribute{
														"regex_fact_condition": schema.SingleNestedAttribute{
															Computed: true,
															Optional: true,
															Attributes: map[string]schema.Attribute{
																"fact": schema.StringAttribute{
																	Computed:    true,
																	Optional:    true,
																	Description: `The name of the value to validate. Should always be 'inputValue' because this property name is passed to the engine. Not Null; must be "inputValue"`,
																	Validators: []validator.String{
																		speakeasy_stringvalidators.NotNull(),
																		stringvalidator.OneOf(
																			"inputValue",
																		),
																	},
																},
																"operator": schema.StringAttribute{
																	Computed:    true,
																	Optional:    true,
																	Description: `The operator to use for comparison. Not Null; must be "regexMatch"`,
																	Validators: []validator.String{
																		speakeasy_stringvalidators.NotNull(),
																		stringvalidator.OneOf(
																			"regexMatch",
																		),
																	},
																},
																"params": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"error_message": schema.StringAttribute{
																			Computed:    true,
																			Optional:    true,
																			Description: `Custom error message`,
																		},
																	},
																	Description: `Additional parameters for the condition`,
																},
																"value": schema.StringAttribute{
																	Computed:    true,
																	Optional:    true,
																	Description: `The actual regex. Not Null`,
																	Validators: []validator.String{
																		speakeasy_stringvalidators.NotNull(),
																	},
																},
															},
															Description: `Fact-based condition for regex validation`,
															Validators: []validator.Object{
																objectvalidator.ConflictsWith(path.Expressions{
																	path.MatchRelative().AtParent().AtName("regex_nested_condition"),
																}...),
															},
														},
														"regex_nested_condition": schema.SingleNestedAttribute{
															Computed: true,
															Optional: true,
															Attributes: map[string]schema.Attribute{
																"one": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"all": schema.ListNestedAttribute{
																			Computed: true,
																			Optional: true,
																			NestedObject: schema.NestedAttributeObject{
																				Validators: []validator.Object{
																					speakeasy_objectvalidators.NotNull(),
																				},
																				Attributes: map[string]schema.Attribute{
																					"fact": schema.StringAttribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `The name of the value to validate. Should always be 'inputValue' because this property name is passed to the engine. Not Null; must be "inputValue"`,
																						Validators: []validator.String{
																							speakeasy_stringvalidators.NotNull(),
																							stringvalidator.OneOf(
																								"inputValue",
																							),
																						},
																					},
																					"operator": schema.StringAttribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `The operator to use for comparison. Not Null; must be "regexMatch"`,
																						Validators: []validator.String{
																							speakeasy_stringvalidators.NotNull(),
																							stringvalidator.OneOf(
																								"regexMatch",
																							),
																						},
																					},
																					"params": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"error_message": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Custom error message`,
																							},
																						},
																						Description: `Additional parameters for the condition`,
																					},
																					"value": schema.StringAttribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `The actual regex. Not Null`,
																						Validators: []validator.String{
																							speakeasy_stringvalidators.NotNull(),
																						},
																					},
																				},
																			},
																			Description: `Not Null`,
																			Validators: []validator.List{
																				speakeasy_listvalidators.NotNull(),
																			},
																		},
																	},
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("two"),
																			path.MatchRelative().AtParent().AtName("three"),
																		}...),
																	},
																},
																"three": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"not": schema.SingleNestedAttribute{
																			Computed: true,
																			Optional: true,
																			Attributes: map[string]schema.Attribute{
																				"fact": schema.StringAttribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `The name of the value to validate. Should always be 'inputValue' because this property name is passed to the engine. Not Null; must be "inputValue"`,
																					Validators: []validator.String{
																						speakeasy_stringvalidators.NotNull(),
																						stringvalidator.OneOf(
																							"inputValue",
																						),
																					},
																				},
																				"operator": schema.StringAttribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `The operator to use for comparison. Not Null; must be "regexMatch"`,
																					Validators: []validator.String{
																						speakeasy_stringvalidators.NotNull(),
																						stringvalidator.OneOf(
																							"regexMatch",
																						),
																					},
																				},
																				"params": schema.SingleNestedAttribute{
																					Computed: true,
																					Optional: true,
																					Attributes: map[string]schema.Attribute{
																						"error_message": schema.StringAttribute{
																							Computed:    true,
																							Optional:    true,
																							Description: `Custom error message`,
																						},
																					},
																					Description: `Additional parameters for the condition`,
																				},
																				"value": schema.StringAttribute{
																					Computed:    true,
																					Optional:    true,
																					Description: `The actual regex. Not Null`,
																					Validators: []validator.String{
																						speakeasy_stringvalidators.NotNull(),
																					},
																				},
																			},
																			Description: `Fact-based condition for regex validation. Not Null`,
																			Validators: []validator.Object{
																				speakeasy_objectvalidators.NotNull(),
																			},
																		},
																	},
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("one"),
																			path.MatchRelative().AtParent().AtName("two"),
																		}...),
																	},
																},
																"two": schema.SingleNestedAttribute{
																	Computed: true,
																	Optional: true,
																	Attributes: map[string]schema.Attribute{
																		"any": schema.ListNestedAttribute{
																			Computed: true,
																			Optional: true,
																			NestedObject: schema.NestedAttributeObject{
																				Validators: []validator.Object{
																					speakeasy_objectvalidators.NotNull(),
																				},
																				Attributes: map[string]schema.Attribute{
																					"fact": schema.StringAttribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `The name of the value to validate. Should always be 'inputValue' because this property name is passed to the engine. Not Null; must be "inputValue"`,
																						Validators: []validator.String{
																							speakeasy_stringvalidators.NotNull(),
																							stringvalidator.OneOf(
																								"inputValue",
																							),
																						},
																					},
																					"operator": schema.StringAttribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `The operator to use for comparison. Not Null; must be "regexMatch"`,
																						Validators: []validator.String{
																							speakeasy_stringvalidators.NotNull(),
																							stringvalidator.OneOf(
																								"regexMatch",
																							),
																						},
																					},
																					"params": schema.SingleNestedAttribute{
																						Computed: true,
																						Optional: true,
																						Attributes: map[string]schema.Attribute{
																							"error_message": schema.StringAttribute{
																								Computed:    true,
																								Optional:    true,
																								Description: `Custom error message`,
																							},
																						},
																						Description: `Additional parameters for the condition`,
																					},
																					"value": schema.StringAttribute{
																						Computed:    true,
																						Optional:    true,
																						Description: `The actual regex. Not Null`,
																						Validators: []validator.String{
																							speakeasy_stringvalidators.NotNull(),
																						},
																					},
																				},
																			},
																			Description: `Not Null`,
																			Validators: []validator.List{
																				speakeasy_listvalidators.NotNull(),
																			},
																		},
																	},
																	Validators: []validator.Object{
																		objectvalidator.ConflictsWith(path.Expressions{
																			path.MatchRelative().AtParent().AtName("one"),
																			path.MatchRelative().AtParent().AtName("three"),
																		}...),
																	},
																},
															},
															Description: `Nested condition with logical operators (level 2 only)`,
															Validators: []validator.Object{
																objectvalidator.ConflictsWith(path.Expressions{
																	path.MatchRelative().AtParent().AtName("regex_fact_condition"),
																}...),
															},
														},
													},
												},
												Description: `Not Null`,
												Validators: []validator.List{
													speakeasy_listvalidators.NotNull(),
												},
											},
										},
										Description: `Any conditions must be true (OR logic)`,
										Validators: []validator.Object{
											objectvalidator.ConflictsWith(path.Expressions{
												path.MatchRelative().AtParent().AtName("one"),
												path.MatchRelative().AtParent().AtName("three"),
											}...),
										},
									},
								},
								Description: `Condition definition for a regex-based validation rule (2 levels deep). Not Null`,
								Validators: []validator.Object{
									speakeasy_objectvalidators.NotNull(),
								},
							},
							"type": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Description: `Indicates this is a regex-based validation rule. Not Null; must be "regex"`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
									stringvalidator.OneOf("regex"),
								},
							},
						},
						Description: `Validation rule that uses a regular expression to validate input.`,
						Validators: []validator.Object{
							objectvalidator.ConflictsWith(path.Expressions{
								path.MatchRelative().AtParent().AtName("numeric_rule_type"),
								path.MatchRelative().AtParent().AtName("pattern_rule_type"),
							}...),
						},
					},
				},
			},
			"schema_version": schema.StringAttribute{
				Computed:    true,
				Description: `Schema version of the validation rule.`,
			},
			"title": schema.StringAttribute{
				Required:    true,
				Description: `Title of the validation rule.`,
			},
			"updated_at": schema.StringAttribute{
				Computed:    true,
				Description: `ISO timestamp when the rule was last updated.`,
			},
			"updated_by": schema.StringAttribute{
				Computed:    true,
				Description: `User ID of the last updater.`,
			},
		},
	}
}

func (r *ValidationRuleResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.SDK)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *sdk.SDK, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *ValidationRuleResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *ValidationRuleResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(plan.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToSharedCreateValidationRuleRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.ValidationRules.CreateValidationRule(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 201 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.ValidationRule != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedValidationRule(ctx, res.ValidationRule)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *ValidationRuleResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *ValidationRuleResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsGetValidationRuleByIDRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.ValidationRules.GetValidationRuleByID(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode == 404 {
		resp.State.RemoveResource(ctx)
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.ValidationRule != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedValidationRule(ctx, res.ValidationRule)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *ValidationRuleResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *ValidationRuleResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	merge(ctx, req, resp, &data)
	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsUpdateValidationRuleRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.ValidationRules.UpdateValidationRule(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.ValidationRule != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedValidationRule(ctx, res.ValidationRule)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *ValidationRuleResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *ValidationRuleResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsDeleteValidationRuleRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.ValidationRules.DeleteValidationRule(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 204 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}

}

func (r *ValidationRuleResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), req.ID)...)
}
