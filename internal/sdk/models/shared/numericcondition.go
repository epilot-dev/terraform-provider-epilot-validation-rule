// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"errors"
	"fmt"
	"github.com/epilot-dev/terraform-provider-epilot-validation-rule/internal/sdk/internal/utils"
)

type NumericConditionNotType string

const (
	NumericConditionNotTypeNumericFactCondition   NumericConditionNotType = "NumericFactCondition"
	NumericConditionNotTypeNumericNestedCondition NumericConditionNotType = "NumericNestedCondition"
)

type NumericConditionNot struct {
	NumericFactCondition   *NumericFactCondition   `queryParam:"inline" name:"not"`
	NumericNestedCondition *NumericNestedCondition `queryParam:"inline" name:"not"`

	Type NumericConditionNotType
}

func CreateNumericConditionNotNumericFactCondition(numericFactCondition NumericFactCondition) NumericConditionNot {
	typ := NumericConditionNotTypeNumericFactCondition

	return NumericConditionNot{
		NumericFactCondition: &numericFactCondition,
		Type:                 typ,
	}
}

func CreateNumericConditionNotNumericNestedCondition(numericNestedCondition NumericNestedCondition) NumericConditionNot {
	typ := NumericConditionNotTypeNumericNestedCondition

	return NumericConditionNot{
		NumericNestedCondition: &numericNestedCondition,
		Type:                   typ,
	}
}

func (u *NumericConditionNot) UnmarshalJSON(data []byte) error {

	var numericFactCondition NumericFactCondition = NumericFactCondition{}
	if err := utils.UnmarshalJSON(data, &numericFactCondition, "", true, nil); err == nil {
		u.NumericFactCondition = &numericFactCondition
		u.Type = NumericConditionNotTypeNumericFactCondition
		return nil
	}

	var numericNestedCondition NumericNestedCondition = NumericNestedCondition{}
	if err := utils.UnmarshalJSON(data, &numericNestedCondition, "", true, nil); err == nil {
		u.NumericNestedCondition = &numericNestedCondition
		u.Type = NumericConditionNotTypeNumericNestedCondition
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for NumericConditionNot", string(data))
}

func (u NumericConditionNot) MarshalJSON() ([]byte, error) {
	if u.NumericFactCondition != nil {
		return utils.MarshalJSON(u.NumericFactCondition, "", true)
	}

	if u.NumericNestedCondition != nil {
		return utils.MarshalJSON(u.NumericNestedCondition, "", true)
	}

	return nil, errors.New("could not marshal union type NumericConditionNot: all fields are null")
}

// NumericCondition3 - NOT condition (negation)
type NumericCondition3 struct {
	Not NumericConditionNot `json:"not"`
}

func (n NumericCondition3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(n, "", false)
}

func (n *NumericCondition3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &n, "", false, []string{"not"}); err != nil {
		return err
	}
	return nil
}

func (o *NumericCondition3) GetNot() NumericConditionNot {
	if o == nil {
		return NumericConditionNot{}
	}
	return o.Not
}

type NumericConditionAnyType string

const (
	NumericConditionAnyTypeNumericFactCondition   NumericConditionAnyType = "NumericFactCondition"
	NumericConditionAnyTypeNumericNestedCondition NumericConditionAnyType = "NumericNestedCondition"
)

type NumericConditionAny struct {
	NumericFactCondition   *NumericFactCondition   `queryParam:"inline" name:"any"`
	NumericNestedCondition *NumericNestedCondition `queryParam:"inline" name:"any"`

	Type NumericConditionAnyType
}

func CreateNumericConditionAnyNumericFactCondition(numericFactCondition NumericFactCondition) NumericConditionAny {
	typ := NumericConditionAnyTypeNumericFactCondition

	return NumericConditionAny{
		NumericFactCondition: &numericFactCondition,
		Type:                 typ,
	}
}

func CreateNumericConditionAnyNumericNestedCondition(numericNestedCondition NumericNestedCondition) NumericConditionAny {
	typ := NumericConditionAnyTypeNumericNestedCondition

	return NumericConditionAny{
		NumericNestedCondition: &numericNestedCondition,
		Type:                   typ,
	}
}

func (u *NumericConditionAny) UnmarshalJSON(data []byte) error {

	var numericFactCondition NumericFactCondition = NumericFactCondition{}
	if err := utils.UnmarshalJSON(data, &numericFactCondition, "", true, nil); err == nil {
		u.NumericFactCondition = &numericFactCondition
		u.Type = NumericConditionAnyTypeNumericFactCondition
		return nil
	}

	var numericNestedCondition NumericNestedCondition = NumericNestedCondition{}
	if err := utils.UnmarshalJSON(data, &numericNestedCondition, "", true, nil); err == nil {
		u.NumericNestedCondition = &numericNestedCondition
		u.Type = NumericConditionAnyTypeNumericNestedCondition
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for NumericConditionAny", string(data))
}

func (u NumericConditionAny) MarshalJSON() ([]byte, error) {
	if u.NumericFactCondition != nil {
		return utils.MarshalJSON(u.NumericFactCondition, "", true)
	}

	if u.NumericNestedCondition != nil {
		return utils.MarshalJSON(u.NumericNestedCondition, "", true)
	}

	return nil, errors.New("could not marshal union type NumericConditionAny: all fields are null")
}

// NumericCondition2 - Any conditions must be true (OR logic)
type NumericCondition2 struct {
	Any []NumericConditionAny `json:"any"`
}

func (n NumericCondition2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(n, "", false)
}

func (n *NumericCondition2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &n, "", false, []string{"any"}); err != nil {
		return err
	}
	return nil
}

func (o *NumericCondition2) GetAny() []NumericConditionAny {
	if o == nil {
		return []NumericConditionAny{}
	}
	return o.Any
}

type NumericConditionAllType string

const (
	NumericConditionAllTypeNumericFactCondition   NumericConditionAllType = "NumericFactCondition"
	NumericConditionAllTypeNumericNestedCondition NumericConditionAllType = "NumericNestedCondition"
)

type NumericConditionAll struct {
	NumericFactCondition   *NumericFactCondition   `queryParam:"inline" name:"all"`
	NumericNestedCondition *NumericNestedCondition `queryParam:"inline" name:"all"`

	Type NumericConditionAllType
}

func CreateNumericConditionAllNumericFactCondition(numericFactCondition NumericFactCondition) NumericConditionAll {
	typ := NumericConditionAllTypeNumericFactCondition

	return NumericConditionAll{
		NumericFactCondition: &numericFactCondition,
		Type:                 typ,
	}
}

func CreateNumericConditionAllNumericNestedCondition(numericNestedCondition NumericNestedCondition) NumericConditionAll {
	typ := NumericConditionAllTypeNumericNestedCondition

	return NumericConditionAll{
		NumericNestedCondition: &numericNestedCondition,
		Type:                   typ,
	}
}

func (u *NumericConditionAll) UnmarshalJSON(data []byte) error {

	var numericFactCondition NumericFactCondition = NumericFactCondition{}
	if err := utils.UnmarshalJSON(data, &numericFactCondition, "", true, nil); err == nil {
		u.NumericFactCondition = &numericFactCondition
		u.Type = NumericConditionAllTypeNumericFactCondition
		return nil
	}

	var numericNestedCondition NumericNestedCondition = NumericNestedCondition{}
	if err := utils.UnmarshalJSON(data, &numericNestedCondition, "", true, nil); err == nil {
		u.NumericNestedCondition = &numericNestedCondition
		u.Type = NumericConditionAllTypeNumericNestedCondition
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for NumericConditionAll", string(data))
}

func (u NumericConditionAll) MarshalJSON() ([]byte, error) {
	if u.NumericFactCondition != nil {
		return utils.MarshalJSON(u.NumericFactCondition, "", true)
	}

	if u.NumericNestedCondition != nil {
		return utils.MarshalJSON(u.NumericNestedCondition, "", true)
	}

	return nil, errors.New("could not marshal union type NumericConditionAll: all fields are null")
}

// NumericCondition1 - All conditions must be true (AND logic)
type NumericCondition1 struct {
	All []NumericConditionAll `json:"all"`
}

func (n NumericCondition1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(n, "", false)
}

func (n *NumericCondition1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &n, "", false, []string{"all"}); err != nil {
		return err
	}
	return nil
}

func (o *NumericCondition1) GetAll() []NumericConditionAll {
	if o == nil {
		return []NumericConditionAll{}
	}
	return o.All
}

type NumericConditionType string

const (
	NumericConditionTypeNumericCondition1 NumericConditionType = "NumericCondition_1"
	NumericConditionTypeNumericCondition2 NumericConditionType = "NumericCondition_2"
	NumericConditionTypeNumericCondition3 NumericConditionType = "NumericCondition_3"
)

// NumericCondition - Condition definition for a numeric-based validation rule (2 levels deep)
type NumericCondition struct {
	NumericCondition1 *NumericCondition1 `queryParam:"inline" name:"NumericCondition"`
	NumericCondition2 *NumericCondition2 `queryParam:"inline" name:"NumericCondition"`
	NumericCondition3 *NumericCondition3 `queryParam:"inline" name:"NumericCondition"`

	Type NumericConditionType
}

func CreateNumericConditionNumericCondition1(numericCondition1 NumericCondition1) NumericCondition {
	typ := NumericConditionTypeNumericCondition1

	return NumericCondition{
		NumericCondition1: &numericCondition1,
		Type:              typ,
	}
}

func CreateNumericConditionNumericCondition2(numericCondition2 NumericCondition2) NumericCondition {
	typ := NumericConditionTypeNumericCondition2

	return NumericCondition{
		NumericCondition2: &numericCondition2,
		Type:              typ,
	}
}

func CreateNumericConditionNumericCondition3(numericCondition3 NumericCondition3) NumericCondition {
	typ := NumericConditionTypeNumericCondition3

	return NumericCondition{
		NumericCondition3: &numericCondition3,
		Type:              typ,
	}
}

func (u *NumericCondition) UnmarshalJSON(data []byte) error {

	var numericCondition1 NumericCondition1 = NumericCondition1{}
	if err := utils.UnmarshalJSON(data, &numericCondition1, "", true, nil); err == nil {
		u.NumericCondition1 = &numericCondition1
		u.Type = NumericConditionTypeNumericCondition1
		return nil
	}

	var numericCondition2 NumericCondition2 = NumericCondition2{}
	if err := utils.UnmarshalJSON(data, &numericCondition2, "", true, nil); err == nil {
		u.NumericCondition2 = &numericCondition2
		u.Type = NumericConditionTypeNumericCondition2
		return nil
	}

	var numericCondition3 NumericCondition3 = NumericCondition3{}
	if err := utils.UnmarshalJSON(data, &numericCondition3, "", true, nil); err == nil {
		u.NumericCondition3 = &numericCondition3
		u.Type = NumericConditionTypeNumericCondition3
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for NumericCondition", string(data))
}

func (u NumericCondition) MarshalJSON() ([]byte, error) {
	if u.NumericCondition1 != nil {
		return utils.MarshalJSON(u.NumericCondition1, "", true)
	}

	if u.NumericCondition2 != nil {
		return utils.MarshalJSON(u.NumericCondition2, "", true)
	}

	if u.NumericCondition3 != nil {
		return utils.MarshalJSON(u.NumericCondition3, "", true)
	}

	return nil, errors.New("could not marshal union type NumericCondition: all fields are null")
}
