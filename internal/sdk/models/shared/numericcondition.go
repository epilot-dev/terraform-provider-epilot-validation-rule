// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"errors"
	"fmt"
	"github.com/epilot-dev/terraform-provider-epilot-validation-rule/internal/sdk/internal/utils"
)

type NumericConditionNotType string

const (
	NumericConditionNotTypeNumericFactCondition   NumericConditionNotType = "NumericFactCondition"
	NumericConditionNotTypeNumericNestedCondition NumericConditionNotType = "NumericNestedCondition"
)

type NumericConditionNot struct {
	NumericFactCondition   *NumericFactCondition   `queryParam:"inline" union:"member"`
	NumericNestedCondition *NumericNestedCondition `queryParam:"inline" union:"member"`

	Type NumericConditionNotType
}

func CreateNumericConditionNotNumericFactCondition(numericFactCondition NumericFactCondition) NumericConditionNot {
	typ := NumericConditionNotTypeNumericFactCondition

	return NumericConditionNot{
		NumericFactCondition: &numericFactCondition,
		Type:                 typ,
	}
}

func CreateNumericConditionNotNumericNestedCondition(numericNestedCondition NumericNestedCondition) NumericConditionNot {
	typ := NumericConditionNotTypeNumericNestedCondition

	return NumericConditionNot{
		NumericNestedCondition: &numericNestedCondition,
		Type:                   typ,
	}
}

func (u *NumericConditionNot) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var numericFactCondition NumericFactCondition = NumericFactCondition{}
	if err := utils.UnmarshalJSON(data, &numericFactCondition, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  NumericConditionNotTypeNumericFactCondition,
			Value: &numericFactCondition,
		})
	}

	var numericNestedCondition NumericNestedCondition = NumericNestedCondition{}
	if err := utils.UnmarshalJSON(data, &numericNestedCondition, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  NumericConditionNotTypeNumericNestedCondition,
			Value: &numericNestedCondition,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for NumericConditionNot", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for NumericConditionNot", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(NumericConditionNotType)
	switch best.Type {
	case NumericConditionNotTypeNumericFactCondition:
		u.NumericFactCondition = best.Value.(*NumericFactCondition)
		return nil
	case NumericConditionNotTypeNumericNestedCondition:
		u.NumericNestedCondition = best.Value.(*NumericNestedCondition)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for NumericConditionNot", string(data))
}

func (u NumericConditionNot) MarshalJSON() ([]byte, error) {
	if u.NumericFactCondition != nil {
		return utils.MarshalJSON(u.NumericFactCondition, "", true)
	}

	if u.NumericNestedCondition != nil {
		return utils.MarshalJSON(u.NumericNestedCondition, "", true)
	}

	return nil, errors.New("could not marshal union type NumericConditionNot: all fields are null")
}

// NumericCondition3 - NOT condition (negation)
type NumericCondition3 struct {
	Not NumericConditionNot `json:"not"`
}

func (n NumericCondition3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(n, "", false)
}

func (n *NumericCondition3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &n, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (n *NumericCondition3) GetNot() NumericConditionNot {
	if n == nil {
		return NumericConditionNot{}
	}
	return n.Not
}

type NumericConditionAnyType string

const (
	NumericConditionAnyTypeNumericFactCondition   NumericConditionAnyType = "NumericFactCondition"
	NumericConditionAnyTypeNumericNestedCondition NumericConditionAnyType = "NumericNestedCondition"
)

type NumericConditionAny struct {
	NumericFactCondition   *NumericFactCondition   `queryParam:"inline" union:"member"`
	NumericNestedCondition *NumericNestedCondition `queryParam:"inline" union:"member"`

	Type NumericConditionAnyType
}

func CreateNumericConditionAnyNumericFactCondition(numericFactCondition NumericFactCondition) NumericConditionAny {
	typ := NumericConditionAnyTypeNumericFactCondition

	return NumericConditionAny{
		NumericFactCondition: &numericFactCondition,
		Type:                 typ,
	}
}

func CreateNumericConditionAnyNumericNestedCondition(numericNestedCondition NumericNestedCondition) NumericConditionAny {
	typ := NumericConditionAnyTypeNumericNestedCondition

	return NumericConditionAny{
		NumericNestedCondition: &numericNestedCondition,
		Type:                   typ,
	}
}

func (u *NumericConditionAny) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var numericFactCondition NumericFactCondition = NumericFactCondition{}
	if err := utils.UnmarshalJSON(data, &numericFactCondition, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  NumericConditionAnyTypeNumericFactCondition,
			Value: &numericFactCondition,
		})
	}

	var numericNestedCondition NumericNestedCondition = NumericNestedCondition{}
	if err := utils.UnmarshalJSON(data, &numericNestedCondition, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  NumericConditionAnyTypeNumericNestedCondition,
			Value: &numericNestedCondition,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for NumericConditionAny", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for NumericConditionAny", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(NumericConditionAnyType)
	switch best.Type {
	case NumericConditionAnyTypeNumericFactCondition:
		u.NumericFactCondition = best.Value.(*NumericFactCondition)
		return nil
	case NumericConditionAnyTypeNumericNestedCondition:
		u.NumericNestedCondition = best.Value.(*NumericNestedCondition)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for NumericConditionAny", string(data))
}

func (u NumericConditionAny) MarshalJSON() ([]byte, error) {
	if u.NumericFactCondition != nil {
		return utils.MarshalJSON(u.NumericFactCondition, "", true)
	}

	if u.NumericNestedCondition != nil {
		return utils.MarshalJSON(u.NumericNestedCondition, "", true)
	}

	return nil, errors.New("could not marshal union type NumericConditionAny: all fields are null")
}

// NumericCondition2 - Any conditions must be true (OR logic)
type NumericCondition2 struct {
	Any []NumericConditionAny `json:"any"`
}

func (n NumericCondition2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(n, "", false)
}

func (n *NumericCondition2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &n, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (n *NumericCondition2) GetAny() []NumericConditionAny {
	if n == nil {
		return []NumericConditionAny{}
	}
	return n.Any
}

type NumericConditionAllType string

const (
	NumericConditionAllTypeNumericFactCondition   NumericConditionAllType = "NumericFactCondition"
	NumericConditionAllTypeNumericNestedCondition NumericConditionAllType = "NumericNestedCondition"
)

type NumericConditionAll struct {
	NumericFactCondition   *NumericFactCondition   `queryParam:"inline" union:"member"`
	NumericNestedCondition *NumericNestedCondition `queryParam:"inline" union:"member"`

	Type NumericConditionAllType
}

func CreateNumericConditionAllNumericFactCondition(numericFactCondition NumericFactCondition) NumericConditionAll {
	typ := NumericConditionAllTypeNumericFactCondition

	return NumericConditionAll{
		NumericFactCondition: &numericFactCondition,
		Type:                 typ,
	}
}

func CreateNumericConditionAllNumericNestedCondition(numericNestedCondition NumericNestedCondition) NumericConditionAll {
	typ := NumericConditionAllTypeNumericNestedCondition

	return NumericConditionAll{
		NumericNestedCondition: &numericNestedCondition,
		Type:                   typ,
	}
}

func (u *NumericConditionAll) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var numericFactCondition NumericFactCondition = NumericFactCondition{}
	if err := utils.UnmarshalJSON(data, &numericFactCondition, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  NumericConditionAllTypeNumericFactCondition,
			Value: &numericFactCondition,
		})
	}

	var numericNestedCondition NumericNestedCondition = NumericNestedCondition{}
	if err := utils.UnmarshalJSON(data, &numericNestedCondition, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  NumericConditionAllTypeNumericNestedCondition,
			Value: &numericNestedCondition,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for NumericConditionAll", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for NumericConditionAll", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(NumericConditionAllType)
	switch best.Type {
	case NumericConditionAllTypeNumericFactCondition:
		u.NumericFactCondition = best.Value.(*NumericFactCondition)
		return nil
	case NumericConditionAllTypeNumericNestedCondition:
		u.NumericNestedCondition = best.Value.(*NumericNestedCondition)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for NumericConditionAll", string(data))
}

func (u NumericConditionAll) MarshalJSON() ([]byte, error) {
	if u.NumericFactCondition != nil {
		return utils.MarshalJSON(u.NumericFactCondition, "", true)
	}

	if u.NumericNestedCondition != nil {
		return utils.MarshalJSON(u.NumericNestedCondition, "", true)
	}

	return nil, errors.New("could not marshal union type NumericConditionAll: all fields are null")
}

// NumericCondition1 - All conditions must be true (AND logic)
type NumericCondition1 struct {
	All []NumericConditionAll `json:"all"`
}

func (n NumericCondition1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(n, "", false)
}

func (n *NumericCondition1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &n, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (n *NumericCondition1) GetAll() []NumericConditionAll {
	if n == nil {
		return []NumericConditionAll{}
	}
	return n.All
}

type NumericConditionType string

const (
	NumericConditionTypeNumericCondition1 NumericConditionType = "NumericCondition_1"
	NumericConditionTypeNumericCondition2 NumericConditionType = "NumericCondition_2"
	NumericConditionTypeNumericCondition3 NumericConditionType = "NumericCondition_3"
)

// NumericCondition - Condition definition for a numeric-based validation rule (2 levels deep)
type NumericCondition struct {
	NumericCondition1 *NumericCondition1 `queryParam:"inline" union:"member"`
	NumericCondition2 *NumericCondition2 `queryParam:"inline" union:"member"`
	NumericCondition3 *NumericCondition3 `queryParam:"inline" union:"member"`

	Type NumericConditionType
}

func CreateNumericConditionNumericCondition1(numericCondition1 NumericCondition1) NumericCondition {
	typ := NumericConditionTypeNumericCondition1

	return NumericCondition{
		NumericCondition1: &numericCondition1,
		Type:              typ,
	}
}

func CreateNumericConditionNumericCondition2(numericCondition2 NumericCondition2) NumericCondition {
	typ := NumericConditionTypeNumericCondition2

	return NumericCondition{
		NumericCondition2: &numericCondition2,
		Type:              typ,
	}
}

func CreateNumericConditionNumericCondition3(numericCondition3 NumericCondition3) NumericCondition {
	typ := NumericConditionTypeNumericCondition3

	return NumericCondition{
		NumericCondition3: &numericCondition3,
		Type:              typ,
	}
}

func (u *NumericCondition) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var numericCondition1 NumericCondition1 = NumericCondition1{}
	if err := utils.UnmarshalJSON(data, &numericCondition1, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  NumericConditionTypeNumericCondition1,
			Value: &numericCondition1,
		})
	}

	var numericCondition2 NumericCondition2 = NumericCondition2{}
	if err := utils.UnmarshalJSON(data, &numericCondition2, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  NumericConditionTypeNumericCondition2,
			Value: &numericCondition2,
		})
	}

	var numericCondition3 NumericCondition3 = NumericCondition3{}
	if err := utils.UnmarshalJSON(data, &numericCondition3, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  NumericConditionTypeNumericCondition3,
			Value: &numericCondition3,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for NumericCondition", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for NumericCondition", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(NumericConditionType)
	switch best.Type {
	case NumericConditionTypeNumericCondition1:
		u.NumericCondition1 = best.Value.(*NumericCondition1)
		return nil
	case NumericConditionTypeNumericCondition2:
		u.NumericCondition2 = best.Value.(*NumericCondition2)
		return nil
	case NumericConditionTypeNumericCondition3:
		u.NumericCondition3 = best.Value.(*NumericCondition3)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for NumericCondition", string(data))
}

func (u NumericCondition) MarshalJSON() ([]byte, error) {
	if u.NumericCondition1 != nil {
		return utils.MarshalJSON(u.NumericCondition1, "", true)
	}

	if u.NumericCondition2 != nil {
		return utils.MarshalJSON(u.NumericCondition2, "", true)
	}

	if u.NumericCondition3 != nil {
		return utils.MarshalJSON(u.NumericCondition3, "", true)
	}

	return nil, errors.New("could not marshal union type NumericCondition: all fields are null")
}
