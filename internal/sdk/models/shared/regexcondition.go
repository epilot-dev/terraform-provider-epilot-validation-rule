// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"errors"
	"fmt"
	"github.com/epilot-dev/terraform-provider-epilot-validation-rule/internal/sdk/internal/utils"
)

type NotType string

const (
	NotTypeRegexFactCondition   NotType = "RegexFactCondition"
	NotTypeRegexNestedCondition NotType = "RegexNestedCondition"
)

type Not struct {
	RegexFactCondition   *RegexFactCondition   `queryParam:"inline" union:"member"`
	RegexNestedCondition *RegexNestedCondition `queryParam:"inline" union:"member"`

	Type NotType
}

func CreateNotRegexFactCondition(regexFactCondition RegexFactCondition) Not {
	typ := NotTypeRegexFactCondition

	return Not{
		RegexFactCondition: &regexFactCondition,
		Type:               typ,
	}
}

func CreateNotRegexNestedCondition(regexNestedCondition RegexNestedCondition) Not {
	typ := NotTypeRegexNestedCondition

	return Not{
		RegexNestedCondition: &regexNestedCondition,
		Type:                 typ,
	}
}

func (u *Not) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var regexFactCondition RegexFactCondition = RegexFactCondition{}
	if err := utils.UnmarshalJSON(data, &regexFactCondition, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  NotTypeRegexFactCondition,
			Value: &regexFactCondition,
		})
	}

	var regexNestedCondition RegexNestedCondition = RegexNestedCondition{}
	if err := utils.UnmarshalJSON(data, &regexNestedCondition, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  NotTypeRegexNestedCondition,
			Value: &regexNestedCondition,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Not", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Not", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(NotType)
	switch best.Type {
	case NotTypeRegexFactCondition:
		u.RegexFactCondition = best.Value.(*RegexFactCondition)
		return nil
	case NotTypeRegexNestedCondition:
		u.RegexNestedCondition = best.Value.(*RegexNestedCondition)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Not", string(data))
}

func (u Not) MarshalJSON() ([]byte, error) {
	if u.RegexFactCondition != nil {
		return utils.MarshalJSON(u.RegexFactCondition, "", true)
	}

	if u.RegexNestedCondition != nil {
		return utils.MarshalJSON(u.RegexNestedCondition, "", true)
	}

	return nil, errors.New("could not marshal union type Not: all fields are null")
}

// RegexCondition3 - NOT condition (negation)
type RegexCondition3 struct {
	Not Not `json:"not"`
}

func (r RegexCondition3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *RegexCondition3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (r *RegexCondition3) GetNot() Not {
	if r == nil {
		return Not{}
	}
	return r.Not
}

type AnyType string

const (
	AnyTypeRegexFactCondition   AnyType = "RegexFactCondition"
	AnyTypeRegexNestedCondition AnyType = "RegexNestedCondition"
)

type Any struct {
	RegexFactCondition   *RegexFactCondition   `queryParam:"inline" union:"member"`
	RegexNestedCondition *RegexNestedCondition `queryParam:"inline" union:"member"`

	Type AnyType
}

func CreateAnyRegexFactCondition(regexFactCondition RegexFactCondition) Any {
	typ := AnyTypeRegexFactCondition

	return Any{
		RegexFactCondition: &regexFactCondition,
		Type:               typ,
	}
}

func CreateAnyRegexNestedCondition(regexNestedCondition RegexNestedCondition) Any {
	typ := AnyTypeRegexNestedCondition

	return Any{
		RegexNestedCondition: &regexNestedCondition,
		Type:                 typ,
	}
}

func (u *Any) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var regexFactCondition RegexFactCondition = RegexFactCondition{}
	if err := utils.UnmarshalJSON(data, &regexFactCondition, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AnyTypeRegexFactCondition,
			Value: &regexFactCondition,
		})
	}

	var regexNestedCondition RegexNestedCondition = RegexNestedCondition{}
	if err := utils.UnmarshalJSON(data, &regexNestedCondition, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AnyTypeRegexNestedCondition,
			Value: &regexNestedCondition,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Any", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for Any", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(AnyType)
	switch best.Type {
	case AnyTypeRegexFactCondition:
		u.RegexFactCondition = best.Value.(*RegexFactCondition)
		return nil
	case AnyTypeRegexNestedCondition:
		u.RegexNestedCondition = best.Value.(*RegexNestedCondition)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Any", string(data))
}

func (u Any) MarshalJSON() ([]byte, error) {
	if u.RegexFactCondition != nil {
		return utils.MarshalJSON(u.RegexFactCondition, "", true)
	}

	if u.RegexNestedCondition != nil {
		return utils.MarshalJSON(u.RegexNestedCondition, "", true)
	}

	return nil, errors.New("could not marshal union type Any: all fields are null")
}

// RegexCondition2 - Any conditions must be true (OR logic)
type RegexCondition2 struct {
	Any []Any `json:"any"`
}

func (r RegexCondition2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *RegexCondition2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (r *RegexCondition2) GetAny() []Any {
	if r == nil {
		return []Any{}
	}
	return r.Any
}

type AllType string

const (
	AllTypeRegexFactCondition   AllType = "RegexFactCondition"
	AllTypeRegexNestedCondition AllType = "RegexNestedCondition"
)

type All struct {
	RegexFactCondition   *RegexFactCondition   `queryParam:"inline" union:"member"`
	RegexNestedCondition *RegexNestedCondition `queryParam:"inline" union:"member"`

	Type AllType
}

func CreateAllRegexFactCondition(regexFactCondition RegexFactCondition) All {
	typ := AllTypeRegexFactCondition

	return All{
		RegexFactCondition: &regexFactCondition,
		Type:               typ,
	}
}

func CreateAllRegexNestedCondition(regexNestedCondition RegexNestedCondition) All {
	typ := AllTypeRegexNestedCondition

	return All{
		RegexNestedCondition: &regexNestedCondition,
		Type:                 typ,
	}
}

func (u *All) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var regexFactCondition RegexFactCondition = RegexFactCondition{}
	if err := utils.UnmarshalJSON(data, &regexFactCondition, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AllTypeRegexFactCondition,
			Value: &regexFactCondition,
		})
	}

	var regexNestedCondition RegexNestedCondition = RegexNestedCondition{}
	if err := utils.UnmarshalJSON(data, &regexNestedCondition, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AllTypeRegexNestedCondition,
			Value: &regexNestedCondition,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for All", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for All", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(AllType)
	switch best.Type {
	case AllTypeRegexFactCondition:
		u.RegexFactCondition = best.Value.(*RegexFactCondition)
		return nil
	case AllTypeRegexNestedCondition:
		u.RegexNestedCondition = best.Value.(*RegexNestedCondition)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for All", string(data))
}

func (u All) MarshalJSON() ([]byte, error) {
	if u.RegexFactCondition != nil {
		return utils.MarshalJSON(u.RegexFactCondition, "", true)
	}

	if u.RegexNestedCondition != nil {
		return utils.MarshalJSON(u.RegexNestedCondition, "", true)
	}

	return nil, errors.New("could not marshal union type All: all fields are null")
}

// RegexCondition1 - All conditions must be true (AND logic)
type RegexCondition1 struct {
	All []All `json:"all"`
}

func (r RegexCondition1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *RegexCondition1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (r *RegexCondition1) GetAll() []All {
	if r == nil {
		return []All{}
	}
	return r.All
}

type RegexConditionType string

const (
	RegexConditionTypeRegexCondition1 RegexConditionType = "RegexCondition_1"
	RegexConditionTypeRegexCondition2 RegexConditionType = "RegexCondition_2"
	RegexConditionTypeRegexCondition3 RegexConditionType = "RegexCondition_3"
)

// RegexCondition - Condition definition for a regex-based validation rule (2 levels deep)
type RegexCondition struct {
	RegexCondition1 *RegexCondition1 `queryParam:"inline" union:"member"`
	RegexCondition2 *RegexCondition2 `queryParam:"inline" union:"member"`
	RegexCondition3 *RegexCondition3 `queryParam:"inline" union:"member"`

	Type RegexConditionType
}

func CreateRegexConditionRegexCondition1(regexCondition1 RegexCondition1) RegexCondition {
	typ := RegexConditionTypeRegexCondition1

	return RegexCondition{
		RegexCondition1: &regexCondition1,
		Type:            typ,
	}
}

func CreateRegexConditionRegexCondition2(regexCondition2 RegexCondition2) RegexCondition {
	typ := RegexConditionTypeRegexCondition2

	return RegexCondition{
		RegexCondition2: &regexCondition2,
		Type:            typ,
	}
}

func CreateRegexConditionRegexCondition3(regexCondition3 RegexCondition3) RegexCondition {
	typ := RegexConditionTypeRegexCondition3

	return RegexCondition{
		RegexCondition3: &regexCondition3,
		Type:            typ,
	}
}

func (u *RegexCondition) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var regexCondition1 RegexCondition1 = RegexCondition1{}
	if err := utils.UnmarshalJSON(data, &regexCondition1, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  RegexConditionTypeRegexCondition1,
			Value: &regexCondition1,
		})
	}

	var regexCondition2 RegexCondition2 = RegexCondition2{}
	if err := utils.UnmarshalJSON(data, &regexCondition2, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  RegexConditionTypeRegexCondition2,
			Value: &regexCondition2,
		})
	}

	var regexCondition3 RegexCondition3 = RegexCondition3{}
	if err := utils.UnmarshalJSON(data, &regexCondition3, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  RegexConditionTypeRegexCondition3,
			Value: &regexCondition3,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for RegexCondition", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for RegexCondition", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(RegexConditionType)
	switch best.Type {
	case RegexConditionTypeRegexCondition1:
		u.RegexCondition1 = best.Value.(*RegexCondition1)
		return nil
	case RegexConditionTypeRegexCondition2:
		u.RegexCondition2 = best.Value.(*RegexCondition2)
		return nil
	case RegexConditionTypeRegexCondition3:
		u.RegexCondition3 = best.Value.(*RegexCondition3)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for RegexCondition", string(data))
}

func (u RegexCondition) MarshalJSON() ([]byte, error) {
	if u.RegexCondition1 != nil {
		return utils.MarshalJSON(u.RegexCondition1, "", true)
	}

	if u.RegexCondition2 != nil {
		return utils.MarshalJSON(u.RegexCondition2, "", true)
	}

	if u.RegexCondition3 != nil {
		return utils.MarshalJSON(u.RegexCondition3, "", true)
	}

	return nil, errors.New("could not marshal union type RegexCondition: all fields are null")
}
