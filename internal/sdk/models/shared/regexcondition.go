// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"errors"
	"fmt"
	"github.com/epilot-dev/terraform-provider-epilot-validation-rule/internal/sdk/internal/utils"
)

type NotType string

const (
	NotTypeRegexFactCondition   NotType = "RegexFactCondition"
	NotTypeRegexNestedCondition NotType = "RegexNestedCondition"
)

type Not struct {
	RegexFactCondition   *RegexFactCondition   `queryParam:"inline" name:"not"`
	RegexNestedCondition *RegexNestedCondition `queryParam:"inline" name:"not"`

	Type NotType
}

func CreateNotRegexFactCondition(regexFactCondition RegexFactCondition) Not {
	typ := NotTypeRegexFactCondition

	return Not{
		RegexFactCondition: &regexFactCondition,
		Type:               typ,
	}
}

func CreateNotRegexNestedCondition(regexNestedCondition RegexNestedCondition) Not {
	typ := NotTypeRegexNestedCondition

	return Not{
		RegexNestedCondition: &regexNestedCondition,
		Type:                 typ,
	}
}

func (u *Not) UnmarshalJSON(data []byte) error {

	var regexFactCondition RegexFactCondition = RegexFactCondition{}
	if err := utils.UnmarshalJSON(data, &regexFactCondition, "", true, nil); err == nil {
		u.RegexFactCondition = &regexFactCondition
		u.Type = NotTypeRegexFactCondition
		return nil
	}

	var regexNestedCondition RegexNestedCondition = RegexNestedCondition{}
	if err := utils.UnmarshalJSON(data, &regexNestedCondition, "", true, nil); err == nil {
		u.RegexNestedCondition = &regexNestedCondition
		u.Type = NotTypeRegexNestedCondition
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Not", string(data))
}

func (u Not) MarshalJSON() ([]byte, error) {
	if u.RegexFactCondition != nil {
		return utils.MarshalJSON(u.RegexFactCondition, "", true)
	}

	if u.RegexNestedCondition != nil {
		return utils.MarshalJSON(u.RegexNestedCondition, "", true)
	}

	return nil, errors.New("could not marshal union type Not: all fields are null")
}

// RegexCondition3 - NOT condition (negation)
type RegexCondition3 struct {
	Not Not `json:"not"`
}

func (r RegexCondition3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *RegexCondition3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, []string{"not"}); err != nil {
		return err
	}
	return nil
}

func (o *RegexCondition3) GetNot() Not {
	if o == nil {
		return Not{}
	}
	return o.Not
}

type AnyType string

const (
	AnyTypeRegexFactCondition   AnyType = "RegexFactCondition"
	AnyTypeRegexNestedCondition AnyType = "RegexNestedCondition"
)

type Any struct {
	RegexFactCondition   *RegexFactCondition   `queryParam:"inline" name:"any"`
	RegexNestedCondition *RegexNestedCondition `queryParam:"inline" name:"any"`

	Type AnyType
}

func CreateAnyRegexFactCondition(regexFactCondition RegexFactCondition) Any {
	typ := AnyTypeRegexFactCondition

	return Any{
		RegexFactCondition: &regexFactCondition,
		Type:               typ,
	}
}

func CreateAnyRegexNestedCondition(regexNestedCondition RegexNestedCondition) Any {
	typ := AnyTypeRegexNestedCondition

	return Any{
		RegexNestedCondition: &regexNestedCondition,
		Type:                 typ,
	}
}

func (u *Any) UnmarshalJSON(data []byte) error {

	var regexFactCondition RegexFactCondition = RegexFactCondition{}
	if err := utils.UnmarshalJSON(data, &regexFactCondition, "", true, nil); err == nil {
		u.RegexFactCondition = &regexFactCondition
		u.Type = AnyTypeRegexFactCondition
		return nil
	}

	var regexNestedCondition RegexNestedCondition = RegexNestedCondition{}
	if err := utils.UnmarshalJSON(data, &regexNestedCondition, "", true, nil); err == nil {
		u.RegexNestedCondition = &regexNestedCondition
		u.Type = AnyTypeRegexNestedCondition
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Any", string(data))
}

func (u Any) MarshalJSON() ([]byte, error) {
	if u.RegexFactCondition != nil {
		return utils.MarshalJSON(u.RegexFactCondition, "", true)
	}

	if u.RegexNestedCondition != nil {
		return utils.MarshalJSON(u.RegexNestedCondition, "", true)
	}

	return nil, errors.New("could not marshal union type Any: all fields are null")
}

// RegexCondition2 - Any conditions must be true (OR logic)
type RegexCondition2 struct {
	Any []Any `json:"any"`
}

func (r RegexCondition2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *RegexCondition2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, []string{"any"}); err != nil {
		return err
	}
	return nil
}

func (o *RegexCondition2) GetAny() []Any {
	if o == nil {
		return []Any{}
	}
	return o.Any
}

type AllType string

const (
	AllTypeRegexFactCondition   AllType = "RegexFactCondition"
	AllTypeRegexNestedCondition AllType = "RegexNestedCondition"
)

type All struct {
	RegexFactCondition   *RegexFactCondition   `queryParam:"inline" name:"all"`
	RegexNestedCondition *RegexNestedCondition `queryParam:"inline" name:"all"`

	Type AllType
}

func CreateAllRegexFactCondition(regexFactCondition RegexFactCondition) All {
	typ := AllTypeRegexFactCondition

	return All{
		RegexFactCondition: &regexFactCondition,
		Type:               typ,
	}
}

func CreateAllRegexNestedCondition(regexNestedCondition RegexNestedCondition) All {
	typ := AllTypeRegexNestedCondition

	return All{
		RegexNestedCondition: &regexNestedCondition,
		Type:                 typ,
	}
}

func (u *All) UnmarshalJSON(data []byte) error {

	var regexFactCondition RegexFactCondition = RegexFactCondition{}
	if err := utils.UnmarshalJSON(data, &regexFactCondition, "", true, nil); err == nil {
		u.RegexFactCondition = &regexFactCondition
		u.Type = AllTypeRegexFactCondition
		return nil
	}

	var regexNestedCondition RegexNestedCondition = RegexNestedCondition{}
	if err := utils.UnmarshalJSON(data, &regexNestedCondition, "", true, nil); err == nil {
		u.RegexNestedCondition = &regexNestedCondition
		u.Type = AllTypeRegexNestedCondition
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for All", string(data))
}

func (u All) MarshalJSON() ([]byte, error) {
	if u.RegexFactCondition != nil {
		return utils.MarshalJSON(u.RegexFactCondition, "", true)
	}

	if u.RegexNestedCondition != nil {
		return utils.MarshalJSON(u.RegexNestedCondition, "", true)
	}

	return nil, errors.New("could not marshal union type All: all fields are null")
}

// RegexCondition1 - All conditions must be true (AND logic)
type RegexCondition1 struct {
	All []All `json:"all"`
}

func (r RegexCondition1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *RegexCondition1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, []string{"all"}); err != nil {
		return err
	}
	return nil
}

func (o *RegexCondition1) GetAll() []All {
	if o == nil {
		return []All{}
	}
	return o.All
}

type RegexConditionType string

const (
	RegexConditionTypeRegexCondition1 RegexConditionType = "RegexCondition_1"
	RegexConditionTypeRegexCondition2 RegexConditionType = "RegexCondition_2"
	RegexConditionTypeRegexCondition3 RegexConditionType = "RegexCondition_3"
)

// RegexCondition - Condition definition for a regex-based validation rule (2 levels deep)
type RegexCondition struct {
	RegexCondition1 *RegexCondition1 `queryParam:"inline" name:"RegexCondition"`
	RegexCondition2 *RegexCondition2 `queryParam:"inline" name:"RegexCondition"`
	RegexCondition3 *RegexCondition3 `queryParam:"inline" name:"RegexCondition"`

	Type RegexConditionType
}

func CreateRegexConditionRegexCondition1(regexCondition1 RegexCondition1) RegexCondition {
	typ := RegexConditionTypeRegexCondition1

	return RegexCondition{
		RegexCondition1: &regexCondition1,
		Type:            typ,
	}
}

func CreateRegexConditionRegexCondition2(regexCondition2 RegexCondition2) RegexCondition {
	typ := RegexConditionTypeRegexCondition2

	return RegexCondition{
		RegexCondition2: &regexCondition2,
		Type:            typ,
	}
}

func CreateRegexConditionRegexCondition3(regexCondition3 RegexCondition3) RegexCondition {
	typ := RegexConditionTypeRegexCondition3

	return RegexCondition{
		RegexCondition3: &regexCondition3,
		Type:            typ,
	}
}

func (u *RegexCondition) UnmarshalJSON(data []byte) error {

	var regexCondition1 RegexCondition1 = RegexCondition1{}
	if err := utils.UnmarshalJSON(data, &regexCondition1, "", true, nil); err == nil {
		u.RegexCondition1 = &regexCondition1
		u.Type = RegexConditionTypeRegexCondition1
		return nil
	}

	var regexCondition2 RegexCondition2 = RegexCondition2{}
	if err := utils.UnmarshalJSON(data, &regexCondition2, "", true, nil); err == nil {
		u.RegexCondition2 = &regexCondition2
		u.Type = RegexConditionTypeRegexCondition2
		return nil
	}

	var regexCondition3 RegexCondition3 = RegexCondition3{}
	if err := utils.UnmarshalJSON(data, &regexCondition3, "", true, nil); err == nil {
		u.RegexCondition3 = &regexCondition3
		u.Type = RegexConditionTypeRegexCondition3
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for RegexCondition", string(data))
}

func (u RegexCondition) MarshalJSON() ([]byte, error) {
	if u.RegexCondition1 != nil {
		return utils.MarshalJSON(u.RegexCondition1, "", true)
	}

	if u.RegexCondition2 != nil {
		return utils.MarshalJSON(u.RegexCondition2, "", true)
	}

	if u.RegexCondition3 != nil {
		return utils.MarshalJSON(u.RegexCondition3, "", true)
	}

	return nil, errors.New("could not marshal union type RegexCondition: all fields are null")
}
