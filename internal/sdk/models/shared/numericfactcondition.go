// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/epilot-dev/terraform-provider-epilot-validation-rule/internal/sdk/internal/utils"
)

// NumericFactConditionSchemasTrue4Fact - Whether the input has leading zeros
type NumericFactConditionSchemasTrue4Fact string

const (
	NumericFactConditionSchemasTrue4FactHasLeadingZeroes NumericFactConditionSchemasTrue4Fact = "has-leading-zeroes"
)

func (e NumericFactConditionSchemasTrue4Fact) ToPointer() *NumericFactConditionSchemasTrue4Fact {
	return &e
}
func (e *NumericFactConditionSchemasTrue4Fact) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "has-leading-zeroes":
		*e = NumericFactConditionSchemasTrue4Fact(v)
		return nil
	default:
		return fmt.Errorf("invalid value for NumericFactConditionSchemasTrue4Fact: %v", v)
	}
}

// NumericFactConditionSchemasTrue4Operator - Leading zeros check operator
type NumericFactConditionSchemasTrue4Operator string

const (
	NumericFactConditionSchemasTrue4OperatorEqual      NumericFactConditionSchemasTrue4Operator = "equal"
	NumericFactConditionSchemasTrue4OperatorNotAllowed NumericFactConditionSchemasTrue4Operator = "notAllowed"
)

func (e NumericFactConditionSchemasTrue4Operator) ToPointer() *NumericFactConditionSchemasTrue4Operator {
	return &e
}
func (e *NumericFactConditionSchemasTrue4Operator) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "equal":
		fallthrough
	case "notAllowed":
		*e = NumericFactConditionSchemasTrue4Operator(v)
		return nil
	default:
		return fmt.Errorf("invalid value for NumericFactConditionSchemasTrue4Operator: %v", v)
	}
}

// NumericFactConditionSchemasTrue4Params - Additional parameters for the condition
type NumericFactConditionSchemasTrue4Params struct {
	// Custom error message
	ErrorMessage *string `json:"errorMessage,omitempty"`
}

func (n NumericFactConditionSchemasTrue4Params) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(n, "", false)
}

func (n *NumericFactConditionSchemasTrue4Params) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &n, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (n *NumericFactConditionSchemasTrue4Params) GetErrorMessage() *string {
	if n == nil {
		return nil
	}
	return n.ErrorMessage
}

// NumericFactCondition4 - Leading zeros validation
type NumericFactCondition4 struct {
	// Whether the input has leading zeros
	Fact NumericFactConditionSchemasTrue4Fact `json:"fact"`
	// Leading zeros check operator
	Operator NumericFactConditionSchemasTrue4Operator `json:"operator"`
	// Additional parameters for the condition
	Params *NumericFactConditionSchemasTrue4Params `json:"params,omitempty"`
	// Whether leading zeros should be present or not
	Value bool `json:"value"`
}

func (n NumericFactCondition4) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(n, "", false)
}

func (n *NumericFactCondition4) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &n, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (n *NumericFactCondition4) GetFact() NumericFactConditionSchemasTrue4Fact {
	if n == nil {
		return NumericFactConditionSchemasTrue4Fact("")
	}
	return n.Fact
}

func (n *NumericFactCondition4) GetOperator() NumericFactConditionSchemasTrue4Operator {
	if n == nil {
		return NumericFactConditionSchemasTrue4Operator("")
	}
	return n.Operator
}

func (n *NumericFactCondition4) GetParams() *NumericFactConditionSchemasTrue4Params {
	if n == nil {
		return nil
	}
	return n.Params
}

func (n *NumericFactCondition4) GetValue() bool {
	if n == nil {
		return false
	}
	return n.Value
}

// NumericFactConditionSchemasTrueFact - Count of decimal digits
type NumericFactConditionSchemasTrueFact string

const (
	NumericFactConditionSchemasTrueFactDecimalDigitsCount NumericFactConditionSchemasTrueFact = "decimal-digits-count"
)

func (e NumericFactConditionSchemasTrueFact) ToPointer() *NumericFactConditionSchemasTrueFact {
	return &e
}
func (e *NumericFactConditionSchemasTrueFact) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "decimal-digits-count":
		*e = NumericFactConditionSchemasTrueFact(v)
		return nil
	default:
		return fmt.Errorf("invalid value for NumericFactConditionSchemasTrueFact: %v", v)
	}
}

// NumericFactConditionSchemasTrueOperator - Decimal digit count comparison operator
type NumericFactConditionSchemasTrueOperator string

const (
	NumericFactConditionSchemasTrueOperatorEqual            NumericFactConditionSchemasTrueOperator = "equal"
	NumericFactConditionSchemasTrueOperatorMinDecimalDigits NumericFactConditionSchemasTrueOperator = "minDecimalDigits"
	NumericFactConditionSchemasTrueOperatorMaxDecimalDigits NumericFactConditionSchemasTrueOperator = "maxDecimalDigits"
)

func (e NumericFactConditionSchemasTrueOperator) ToPointer() *NumericFactConditionSchemasTrueOperator {
	return &e
}
func (e *NumericFactConditionSchemasTrueOperator) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "equal":
		fallthrough
	case "minDecimalDigits":
		fallthrough
	case "maxDecimalDigits":
		*e = NumericFactConditionSchemasTrueOperator(v)
		return nil
	default:
		return fmt.Errorf("invalid value for NumericFactConditionSchemasTrueOperator: %v", v)
	}
}

// NumericFactConditionSchemasTrueParams - Additional parameters for the condition
type NumericFactConditionSchemasTrueParams struct {
	// Custom error message
	ErrorMessage *string `json:"errorMessage,omitempty"`
}

func (n NumericFactConditionSchemasTrueParams) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(n, "", false)
}

func (n *NumericFactConditionSchemasTrueParams) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &n, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (n *NumericFactConditionSchemasTrueParams) GetErrorMessage() *string {
	if n == nil {
		return nil
	}
	return n.ErrorMessage
}

// NumericFactCondition3 - Decimal digits count validation
type NumericFactCondition3 struct {
	// Count of decimal digits
	Fact NumericFactConditionSchemasTrueFact `json:"fact"`
	// Decimal digit count comparison operator
	Operator NumericFactConditionSchemasTrueOperator `json:"operator"`
	// Additional parameters for the condition
	Params *NumericFactConditionSchemasTrueParams `json:"params,omitempty"`
	// Expected number of decimal digits
	Value float64 `json:"value"`
}

func (n NumericFactCondition3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(n, "", false)
}

func (n *NumericFactCondition3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &n, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (n *NumericFactCondition3) GetFact() NumericFactConditionSchemasTrueFact {
	if n == nil {
		return NumericFactConditionSchemasTrueFact("")
	}
	return n.Fact
}

func (n *NumericFactCondition3) GetOperator() NumericFactConditionSchemasTrueOperator {
	if n == nil {
		return NumericFactConditionSchemasTrueOperator("")
	}
	return n.Operator
}

func (n *NumericFactCondition3) GetParams() *NumericFactConditionSchemasTrueParams {
	if n == nil {
		return nil
	}
	return n.Params
}

func (n *NumericFactCondition3) GetValue() float64 {
	if n == nil {
		return 0.0
	}
	return n.Value
}

// NumericFactConditionSchemasFact - Count of integer digits (excludes leading zeros unless allowed)
type NumericFactConditionSchemasFact string

const (
	NumericFactConditionSchemasFactIntegerDigitsCount NumericFactConditionSchemasFact = "integer-digits-count"
)

func (e NumericFactConditionSchemasFact) ToPointer() *NumericFactConditionSchemasFact {
	return &e
}
func (e *NumericFactConditionSchemasFact) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "integer-digits-count":
		*e = NumericFactConditionSchemasFact(v)
		return nil
	default:
		return fmt.Errorf("invalid value for NumericFactConditionSchemasFact: %v", v)
	}
}

// NumericFactConditionSchemasOperator - Digit count comparison operator
type NumericFactConditionSchemasOperator string

const (
	NumericFactConditionSchemasOperatorEqual            NumericFactConditionSchemasOperator = "equal"
	NumericFactConditionSchemasOperatorExactlyNDigits   NumericFactConditionSchemasOperator = "exactlyNDigits"
	NumericFactConditionSchemasOperatorMinIntegerDigits NumericFactConditionSchemasOperator = "minIntegerDigits"
	NumericFactConditionSchemasOperatorMaxIntegerDigits NumericFactConditionSchemasOperator = "maxIntegerDigits"
)

func (e NumericFactConditionSchemasOperator) ToPointer() *NumericFactConditionSchemasOperator {
	return &e
}
func (e *NumericFactConditionSchemasOperator) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "equal":
		fallthrough
	case "exactlyNDigits":
		fallthrough
	case "minIntegerDigits":
		fallthrough
	case "maxIntegerDigits":
		*e = NumericFactConditionSchemasOperator(v)
		return nil
	default:
		return fmt.Errorf("invalid value for NumericFactConditionSchemasOperator: %v", v)
	}
}

// NumericFactConditionSchemasParams - Additional parameters for the condition
type NumericFactConditionSchemasParams struct {
	// Whether to count leading zeroes in digit count
	AllowLeadingZeroes *bool `default:"false" json:"allowLeadingZeroes"`
	// Custom error message
	ErrorMessage *string `json:"errorMessage,omitempty"`
}

func (n NumericFactConditionSchemasParams) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(n, "", false)
}

func (n *NumericFactConditionSchemasParams) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &n, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (n *NumericFactConditionSchemasParams) GetAllowLeadingZeroes() *bool {
	if n == nil {
		return nil
	}
	return n.AllowLeadingZeroes
}

func (n *NumericFactConditionSchemasParams) GetErrorMessage() *string {
	if n == nil {
		return nil
	}
	return n.ErrorMessage
}

// NumericFactCondition2 - Integer digits count validation
type NumericFactCondition2 struct {
	// Count of integer digits (excludes leading zeros unless allowed)
	Fact NumericFactConditionSchemasFact `json:"fact"`
	// Digit count comparison operator
	Operator NumericFactConditionSchemasOperator `json:"operator"`
	// Additional parameters for the condition
	Params *NumericFactConditionSchemasParams `json:"params,omitempty"`
	// Expected number of integer digits
	Value float64 `json:"value"`
}

func (n NumericFactCondition2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(n, "", false)
}

func (n *NumericFactCondition2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &n, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (n *NumericFactCondition2) GetFact() NumericFactConditionSchemasFact {
	if n == nil {
		return NumericFactConditionSchemasFact("")
	}
	return n.Fact
}

func (n *NumericFactCondition2) GetOperator() NumericFactConditionSchemasOperator {
	if n == nil {
		return NumericFactConditionSchemasOperator("")
	}
	return n.Operator
}

func (n *NumericFactCondition2) GetParams() *NumericFactConditionSchemasParams {
	if n == nil {
		return nil
	}
	return n.Params
}

func (n *NumericFactCondition2) GetValue() float64 {
	if n == nil {
		return 0.0
	}
	return n.Value
}

// NumericFactConditionFact - The numeric value extracted from input; The amount of digits
type NumericFactConditionFact string

const (
	NumericFactConditionFactNumericValue NumericFactConditionFact = "numeric-value"
	NumericFactConditionFactTotalLength  NumericFactConditionFact = "total-length"
)

func (e NumericFactConditionFact) ToPointer() *NumericFactConditionFact {
	return &e
}
func (e *NumericFactConditionFact) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "numeric-value":
		fallthrough
	case "total-length":
		*e = NumericFactConditionFact(v)
		return nil
	default:
		return fmt.Errorf("invalid value for NumericFactConditionFact: %v", v)
	}
}

// NumericFactConditionOperator - Numeric comparison operator
type NumericFactConditionOperator string

const (
	NumericFactConditionOperatorEqual                NumericFactConditionOperator = "equal"
	NumericFactConditionOperatorNotEqual             NumericFactConditionOperator = "notEqual"
	NumericFactConditionOperatorLessThan             NumericFactConditionOperator = "lessThan"
	NumericFactConditionOperatorLessThanInclusive    NumericFactConditionOperator = "lessThanInclusive"
	NumericFactConditionOperatorGreaterThan          NumericFactConditionOperator = "greaterThan"
	NumericFactConditionOperatorGreaterThanInclusive NumericFactConditionOperator = "greaterThanInclusive"
)

func (e NumericFactConditionOperator) ToPointer() *NumericFactConditionOperator {
	return &e
}
func (e *NumericFactConditionOperator) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "equal":
		fallthrough
	case "notEqual":
		fallthrough
	case "lessThan":
		fallthrough
	case "lessThanInclusive":
		fallthrough
	case "greaterThan":
		fallthrough
	case "greaterThanInclusive":
		*e = NumericFactConditionOperator(v)
		return nil
	default:
		return fmt.Errorf("invalid value for NumericFactConditionOperator: %v", v)
	}
}

// NumericFactConditionParams - Additional parameters for the condition
type NumericFactConditionParams struct {
	// Custom error message
	ErrorMessage *string `json:"errorMessage,omitempty"`
}

func (n NumericFactConditionParams) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(n, "", false)
}

func (n *NumericFactConditionParams) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &n, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (n *NumericFactConditionParams) GetErrorMessage() *string {
	if n == nil {
		return nil
	}
	return n.ErrorMessage
}

// NumericFactCondition1 - Numeric value comparison
type NumericFactCondition1 struct {
	// The numeric value extracted from input; The amount of digits
	Fact NumericFactConditionFact `json:"fact"`
	// Numeric comparison operator
	Operator NumericFactConditionOperator `json:"operator"`
	// Additional parameters for the condition
	Params *NumericFactConditionParams `json:"params,omitempty"`
	// Numeric value to compare against
	Value float64 `json:"value"`
}

func (n NumericFactCondition1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(n, "", false)
}

func (n *NumericFactCondition1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &n, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (n *NumericFactCondition1) GetFact() NumericFactConditionFact {
	if n == nil {
		return NumericFactConditionFact("")
	}
	return n.Fact
}

func (n *NumericFactCondition1) GetOperator() NumericFactConditionOperator {
	if n == nil {
		return NumericFactConditionOperator("")
	}
	return n.Operator
}

func (n *NumericFactCondition1) GetParams() *NumericFactConditionParams {
	if n == nil {
		return nil
	}
	return n.Params
}

func (n *NumericFactCondition1) GetValue() float64 {
	if n == nil {
		return 0.0
	}
	return n.Value
}

type NumericFactConditionType string

const (
	NumericFactConditionTypeNumericFactCondition1 NumericFactConditionType = "NumericFactCondition_1"
	NumericFactConditionTypeNumericFactCondition2 NumericFactConditionType = "NumericFactCondition_2"
	NumericFactConditionTypeNumericFactCondition3 NumericFactConditionType = "NumericFactCondition_3"
	NumericFactConditionTypeNumericFactCondition4 NumericFactConditionType = "NumericFactCondition_4"
)

// NumericFactCondition - Fact-based condition for numeric validation
type NumericFactCondition struct {
	NumericFactCondition1 *NumericFactCondition1 `queryParam:"inline" union:"member"`
	NumericFactCondition2 *NumericFactCondition2 `queryParam:"inline" union:"member"`
	NumericFactCondition3 *NumericFactCondition3 `queryParam:"inline" union:"member"`
	NumericFactCondition4 *NumericFactCondition4 `queryParam:"inline" union:"member"`

	Type NumericFactConditionType
}

func CreateNumericFactConditionNumericFactCondition1(numericFactCondition1 NumericFactCondition1) NumericFactCondition {
	typ := NumericFactConditionTypeNumericFactCondition1

	return NumericFactCondition{
		NumericFactCondition1: &numericFactCondition1,
		Type:                  typ,
	}
}

func CreateNumericFactConditionNumericFactCondition2(numericFactCondition2 NumericFactCondition2) NumericFactCondition {
	typ := NumericFactConditionTypeNumericFactCondition2

	return NumericFactCondition{
		NumericFactCondition2: &numericFactCondition2,
		Type:                  typ,
	}
}

func CreateNumericFactConditionNumericFactCondition3(numericFactCondition3 NumericFactCondition3) NumericFactCondition {
	typ := NumericFactConditionTypeNumericFactCondition3

	return NumericFactCondition{
		NumericFactCondition3: &numericFactCondition3,
		Type:                  typ,
	}
}

func CreateNumericFactConditionNumericFactCondition4(numericFactCondition4 NumericFactCondition4) NumericFactCondition {
	typ := NumericFactConditionTypeNumericFactCondition4

	return NumericFactCondition{
		NumericFactCondition4: &numericFactCondition4,
		Type:                  typ,
	}
}

func (u *NumericFactCondition) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var numericFactCondition1 NumericFactCondition1 = NumericFactCondition1{}
	if err := utils.UnmarshalJSON(data, &numericFactCondition1, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  NumericFactConditionTypeNumericFactCondition1,
			Value: &numericFactCondition1,
		})
	}

	var numericFactCondition2 NumericFactCondition2 = NumericFactCondition2{}
	if err := utils.UnmarshalJSON(data, &numericFactCondition2, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  NumericFactConditionTypeNumericFactCondition2,
			Value: &numericFactCondition2,
		})
	}

	var numericFactCondition3 NumericFactCondition3 = NumericFactCondition3{}
	if err := utils.UnmarshalJSON(data, &numericFactCondition3, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  NumericFactConditionTypeNumericFactCondition3,
			Value: &numericFactCondition3,
		})
	}

	var numericFactCondition4 NumericFactCondition4 = NumericFactCondition4{}
	if err := utils.UnmarshalJSON(data, &numericFactCondition4, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  NumericFactConditionTypeNumericFactCondition4,
			Value: &numericFactCondition4,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for NumericFactCondition", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for NumericFactCondition", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(NumericFactConditionType)
	switch best.Type {
	case NumericFactConditionTypeNumericFactCondition1:
		u.NumericFactCondition1 = best.Value.(*NumericFactCondition1)
		return nil
	case NumericFactConditionTypeNumericFactCondition2:
		u.NumericFactCondition2 = best.Value.(*NumericFactCondition2)
		return nil
	case NumericFactConditionTypeNumericFactCondition3:
		u.NumericFactCondition3 = best.Value.(*NumericFactCondition3)
		return nil
	case NumericFactConditionTypeNumericFactCondition4:
		u.NumericFactCondition4 = best.Value.(*NumericFactCondition4)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for NumericFactCondition", string(data))
}

func (u NumericFactCondition) MarshalJSON() ([]byte, error) {
	if u.NumericFactCondition1 != nil {
		return utils.MarshalJSON(u.NumericFactCondition1, "", true)
	}

	if u.NumericFactCondition2 != nil {
		return utils.MarshalJSON(u.NumericFactCondition2, "", true)
	}

	if u.NumericFactCondition3 != nil {
		return utils.MarshalJSON(u.NumericFactCondition3, "", true)
	}

	if u.NumericFactCondition4 != nil {
		return utils.MarshalJSON(u.NumericFactCondition4, "", true)
	}

	return nil, errors.New("could not marshal union type NumericFactCondition: all fields are null")
}
