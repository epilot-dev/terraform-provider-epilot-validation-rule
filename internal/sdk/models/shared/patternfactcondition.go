// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/epilot-dev/terraform-provider-epilot-validation-rule/internal/sdk/internal/utils"
)

// PatternFactConditionSchemasTrue4Fact - The name of the value to validate.
type PatternFactConditionSchemasTrue4Fact string

const (
	PatternFactConditionSchemasTrue4FactStaticCheck PatternFactConditionSchemasTrue4Fact = "static-check"
)

func (e PatternFactConditionSchemasTrue4Fact) ToPointer() *PatternFactConditionSchemasTrue4Fact {
	return &e
}
func (e *PatternFactConditionSchemasTrue4Fact) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "static-check":
		*e = PatternFactConditionSchemasTrue4Fact(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PatternFactConditionSchemasTrue4Fact: %v", v)
	}
}

// PatternFactConditionSchemasTrue4Operator - String comparison operator
type PatternFactConditionSchemasTrue4Operator string

const (
	PatternFactConditionSchemasTrue4OperatorEqual    PatternFactConditionSchemasTrue4Operator = "equal"
	PatternFactConditionSchemasTrue4OperatorNotEqual PatternFactConditionSchemasTrue4Operator = "notEqual"
)

func (e PatternFactConditionSchemasTrue4Operator) ToPointer() *PatternFactConditionSchemasTrue4Operator {
	return &e
}
func (e *PatternFactConditionSchemasTrue4Operator) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "equal":
		fallthrough
	case "notEqual":
		*e = PatternFactConditionSchemasTrue4Operator(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PatternFactConditionSchemasTrue4Operator: %v", v)
	}
}

// PatternFactConditionSchemasTrue4Params - Additional parameters for the condition
type PatternFactConditionSchemasTrue4Params struct {
	// To where to check
	End *float64 `json:"end,omitempty"`
	// Custom error message
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// From where to check
	Start *float64 `json:"start,omitempty"`
}

func (p PatternFactConditionSchemasTrue4Params) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PatternFactConditionSchemasTrue4Params) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (p *PatternFactConditionSchemasTrue4Params) GetEnd() *float64 {
	if p == nil {
		return nil
	}
	return p.End
}

func (p *PatternFactConditionSchemasTrue4Params) GetErrorMessage() *string {
	if p == nil {
		return nil
	}
	return p.ErrorMessage
}

func (p *PatternFactConditionSchemasTrue4Params) GetStart() *float64 {
	if p == nil {
		return nil
	}
	return p.Start
}

// Four - String-based condition
type Four struct {
	// The name of the value to validate.
	Fact PatternFactConditionSchemasTrue4Fact `json:"fact"`
	// String comparison operator
	Operator PatternFactConditionSchemasTrue4Operator `json:"operator"`
	// Additional parameters for the condition
	Params *PatternFactConditionSchemasTrue4Params `json:"params,omitempty"`
	// String value to compare against
	Value string `json:"value"`
}

func (f Four) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *Four) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (f *Four) GetFact() PatternFactConditionSchemasTrue4Fact {
	if f == nil {
		return PatternFactConditionSchemasTrue4Fact("")
	}
	return f.Fact
}

func (f *Four) GetOperator() PatternFactConditionSchemasTrue4Operator {
	if f == nil {
		return PatternFactConditionSchemasTrue4Operator("")
	}
	return f.Operator
}

func (f *Four) GetParams() *PatternFactConditionSchemasTrue4Params {
	if f == nil {
		return nil
	}
	return f.Params
}

func (f *Four) GetValue() string {
	if f == nil {
		return ""
	}
	return f.Value
}

// PatternFactConditionSchemasTrueFact - The name of the value to validate.
type PatternFactConditionSchemasTrueFact string

const (
	PatternFactConditionSchemasTrueFactStaticCheck PatternFactConditionSchemasTrueFact = "static-check"
)

func (e PatternFactConditionSchemasTrueFact) ToPointer() *PatternFactConditionSchemasTrueFact {
	return &e
}
func (e *PatternFactConditionSchemasTrueFact) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "static-check":
		*e = PatternFactConditionSchemasTrueFact(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PatternFactConditionSchemasTrueFact: %v", v)
	}
}

// PatternFactConditionSchemasTrueOperator - Array-based comparison operator
type PatternFactConditionSchemasTrueOperator string

const (
	PatternFactConditionSchemasTrueOperatorIn             PatternFactConditionSchemasTrueOperator = "in"
	PatternFactConditionSchemasTrueOperatorNotIn          PatternFactConditionSchemasTrueOperator = "notIn"
	PatternFactConditionSchemasTrueOperatorContains       PatternFactConditionSchemasTrueOperator = "contains"
	PatternFactConditionSchemasTrueOperatorDoesNotContain PatternFactConditionSchemasTrueOperator = "doesNotContain"
)

func (e PatternFactConditionSchemasTrueOperator) ToPointer() *PatternFactConditionSchemasTrueOperator {
	return &e
}
func (e *PatternFactConditionSchemasTrueOperator) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "in":
		fallthrough
	case "notIn":
		fallthrough
	case "contains":
		fallthrough
	case "doesNotContain":
		*e = PatternFactConditionSchemasTrueOperator(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PatternFactConditionSchemasTrueOperator: %v", v)
	}
}

// PatternFactConditionSchemasTrueParams - Additional parameters for the condition
type PatternFactConditionSchemasTrueParams struct {
	// To where to check
	End *float64 `json:"end,omitempty"`
	// Custom error message
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// From where to check
	Start *float64 `json:"start,omitempty"`
}

func (p PatternFactConditionSchemasTrueParams) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PatternFactConditionSchemasTrueParams) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (p *PatternFactConditionSchemasTrueParams) GetEnd() *float64 {
	if p == nil {
		return nil
	}
	return p.End
}

func (p *PatternFactConditionSchemasTrueParams) GetErrorMessage() *string {
	if p == nil {
		return nil
	}
	return p.ErrorMessage
}

func (p *PatternFactConditionSchemasTrueParams) GetStart() *float64 {
	if p == nil {
		return nil
	}
	return p.Start
}

// PatternFactCondition3 - Array-based condition (in, notIn, contains, doesNotContain)
type PatternFactCondition3 struct {
	// The name of the value to validate.
	Fact PatternFactConditionSchemasTrueFact `json:"fact"`
	// Array-based comparison operator
	Operator PatternFactConditionSchemasTrueOperator `json:"operator"`
	// Additional parameters for the condition
	Params *PatternFactConditionSchemasTrueParams `json:"params,omitempty"`
	// Array of string values for array-based operators
	Value []string `json:"value"`
}

func (p PatternFactCondition3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PatternFactCondition3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (p *PatternFactCondition3) GetFact() PatternFactConditionSchemasTrueFact {
	if p == nil {
		return PatternFactConditionSchemasTrueFact("")
	}
	return p.Fact
}

func (p *PatternFactCondition3) GetOperator() PatternFactConditionSchemasTrueOperator {
	if p == nil {
		return PatternFactConditionSchemasTrueOperator("")
	}
	return p.Operator
}

func (p *PatternFactCondition3) GetParams() *PatternFactConditionSchemasTrueParams {
	if p == nil {
		return nil
	}
	return p.Params
}

func (p *PatternFactCondition3) GetValue() []string {
	if p == nil {
		return []string{}
	}
	return p.Value
}

// PatternFactConditionSchemasFact - The name of the value to validate.
type PatternFactConditionSchemasFact string

const (
	PatternFactConditionSchemasFactStaticCheck PatternFactConditionSchemasFact = "static-check"
	PatternFactConditionSchemasFactTotalLength PatternFactConditionSchemasFact = "total-length"
)

func (e PatternFactConditionSchemasFact) ToPointer() *PatternFactConditionSchemasFact {
	return &e
}
func (e *PatternFactConditionSchemasFact) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "static-check":
		fallthrough
	case "total-length":
		*e = PatternFactConditionSchemasFact(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PatternFactConditionSchemasFact: %v", v)
	}
}

// PatternFactConditionSchemasOperator - Exact digit count operator
type PatternFactConditionSchemasOperator string

const (
	PatternFactConditionSchemasOperatorExactlyNDigits PatternFactConditionSchemasOperator = "exactlyNDigits"
)

func (e PatternFactConditionSchemasOperator) ToPointer() *PatternFactConditionSchemasOperator {
	return &e
}
func (e *PatternFactConditionSchemasOperator) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "exactlyNDigits":
		*e = PatternFactConditionSchemasOperator(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PatternFactConditionSchemasOperator: %v", v)
	}
}

// PatternFactConditionSchemasParams - Additional parameters for the condition
type PatternFactConditionSchemasParams struct {
	// To where to check
	End *float64 `json:"end,omitempty"`
	// Custom error message
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// From where to check
	Start *float64 `json:"start,omitempty"`
}

func (p PatternFactConditionSchemasParams) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PatternFactConditionSchemasParams) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (p *PatternFactConditionSchemasParams) GetEnd() *float64 {
	if p == nil {
		return nil
	}
	return p.End
}

func (p *PatternFactConditionSchemasParams) GetErrorMessage() *string {
	if p == nil {
		return nil
	}
	return p.ErrorMessage
}

func (p *PatternFactConditionSchemasParams) GetStart() *float64 {
	if p == nil {
		return nil
	}
	return p.Start
}

// PatternFactCondition2 - Exact digits condition
type PatternFactCondition2 struct {
	// The name of the value to validate.
	Fact PatternFactConditionSchemasFact `json:"fact"`
	// Exact digit count operator
	Operator PatternFactConditionSchemasOperator `json:"operator"`
	// Additional parameters for the condition
	Params *PatternFactConditionSchemasParams `json:"params,omitempty"`
	// Number of digits required
	Value float64 `json:"value"`
}

func (p PatternFactCondition2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PatternFactCondition2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (p *PatternFactCondition2) GetFact() PatternFactConditionSchemasFact {
	if p == nil {
		return PatternFactConditionSchemasFact("")
	}
	return p.Fact
}

func (p *PatternFactCondition2) GetOperator() PatternFactConditionSchemasOperator {
	if p == nil {
		return PatternFactConditionSchemasOperator("")
	}
	return p.Operator
}

func (p *PatternFactCondition2) GetParams() *PatternFactConditionSchemasParams {
	if p == nil {
		return nil
	}
	return p.Params
}

func (p *PatternFactCondition2) GetValue() float64 {
	if p == nil {
		return 0.0
	}
	return p.Value
}

// PatternFactConditionFact - The name of the value to validate.
type PatternFactConditionFact string

const (
	PatternFactConditionFactTotalLength PatternFactConditionFact = "total-length"
)

func (e PatternFactConditionFact) ToPointer() *PatternFactConditionFact {
	return &e
}
func (e *PatternFactConditionFact) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "total-length":
		*e = PatternFactConditionFact(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PatternFactConditionFact: %v", v)
	}
}

// PatternFactConditionOperator - Numeric comparison operator
type PatternFactConditionOperator string

const (
	PatternFactConditionOperatorEqual                PatternFactConditionOperator = "equal"
	PatternFactConditionOperatorNotEqual             PatternFactConditionOperator = "notEqual"
	PatternFactConditionOperatorLessThan             PatternFactConditionOperator = "lessThan"
	PatternFactConditionOperatorLessThanInclusive    PatternFactConditionOperator = "lessThanInclusive"
	PatternFactConditionOperatorGreaterThan          PatternFactConditionOperator = "greaterThan"
	PatternFactConditionOperatorGreaterThanInclusive PatternFactConditionOperator = "greaterThanInclusive"
)

func (e PatternFactConditionOperator) ToPointer() *PatternFactConditionOperator {
	return &e
}
func (e *PatternFactConditionOperator) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "equal":
		fallthrough
	case "notEqual":
		fallthrough
	case "lessThan":
		fallthrough
	case "lessThanInclusive":
		fallthrough
	case "greaterThan":
		fallthrough
	case "greaterThanInclusive":
		*e = PatternFactConditionOperator(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PatternFactConditionOperator: %v", v)
	}
}

// PatternFactConditionParams - Additional parameters for the condition
type PatternFactConditionParams struct {
	// To where to check
	End *float64 `json:"end,omitempty"`
	// Custom error message
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// From where to check
	Start *float64 `json:"start,omitempty"`
}

func (p PatternFactConditionParams) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PatternFactConditionParams) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (p *PatternFactConditionParams) GetEnd() *float64 {
	if p == nil {
		return nil
	}
	return p.End
}

func (p *PatternFactConditionParams) GetErrorMessage() *string {
	if p == nil {
		return nil
	}
	return p.ErrorMessage
}

func (p *PatternFactConditionParams) GetStart() *float64 {
	if p == nil {
		return nil
	}
	return p.Start
}

// PatternFactCondition1 - Numeric condition (total-length fact)
type PatternFactCondition1 struct {
	// The name of the value to validate.
	Fact PatternFactConditionFact `json:"fact"`
	// Numeric comparison operator
	Operator PatternFactConditionOperator `json:"operator"`
	// Additional parameters for the condition
	Params *PatternFactConditionParams `json:"params,omitempty"`
	// Numeric value to compare against
	Value float64 `json:"value"`
}

func (p PatternFactCondition1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PatternFactCondition1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (p *PatternFactCondition1) GetFact() PatternFactConditionFact {
	if p == nil {
		return PatternFactConditionFact("")
	}
	return p.Fact
}

func (p *PatternFactCondition1) GetOperator() PatternFactConditionOperator {
	if p == nil {
		return PatternFactConditionOperator("")
	}
	return p.Operator
}

func (p *PatternFactCondition1) GetParams() *PatternFactConditionParams {
	if p == nil {
		return nil
	}
	return p.Params
}

func (p *PatternFactCondition1) GetValue() float64 {
	if p == nil {
		return 0.0
	}
	return p.Value
}

type PatternFactConditionType string

const (
	PatternFactConditionTypePatternFactCondition1 PatternFactConditionType = "PatternFactCondition_1"
	PatternFactConditionTypePatternFactCondition2 PatternFactConditionType = "PatternFactCondition_2"
	PatternFactConditionTypePatternFactCondition3 PatternFactConditionType = "PatternFactCondition_3"
	PatternFactConditionTypeFour                  PatternFactConditionType = "4"
)

// PatternFactCondition - Fact-based condition for pattern validation
type PatternFactCondition struct {
	PatternFactCondition1 *PatternFactCondition1 `queryParam:"inline" union:"member"`
	PatternFactCondition2 *PatternFactCondition2 `queryParam:"inline" union:"member"`
	PatternFactCondition3 *PatternFactCondition3 `queryParam:"inline" union:"member"`
	Four                  *Four                  `queryParam:"inline" union:"member"`

	Type PatternFactConditionType
}

func CreatePatternFactConditionPatternFactCondition1(patternFactCondition1 PatternFactCondition1) PatternFactCondition {
	typ := PatternFactConditionTypePatternFactCondition1

	return PatternFactCondition{
		PatternFactCondition1: &patternFactCondition1,
		Type:                  typ,
	}
}

func CreatePatternFactConditionPatternFactCondition2(patternFactCondition2 PatternFactCondition2) PatternFactCondition {
	typ := PatternFactConditionTypePatternFactCondition2

	return PatternFactCondition{
		PatternFactCondition2: &patternFactCondition2,
		Type:                  typ,
	}
}

func CreatePatternFactConditionPatternFactCondition3(patternFactCondition3 PatternFactCondition3) PatternFactCondition {
	typ := PatternFactConditionTypePatternFactCondition3

	return PatternFactCondition{
		PatternFactCondition3: &patternFactCondition3,
		Type:                  typ,
	}
}

func CreatePatternFactConditionFour(four Four) PatternFactCondition {
	typ := PatternFactConditionTypeFour

	return PatternFactCondition{
		Four: &four,
		Type: typ,
	}
}

func (u *PatternFactCondition) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var patternFactCondition1 PatternFactCondition1 = PatternFactCondition1{}
	if err := utils.UnmarshalJSON(data, &patternFactCondition1, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  PatternFactConditionTypePatternFactCondition1,
			Value: &patternFactCondition1,
		})
	}

	var patternFactCondition2 PatternFactCondition2 = PatternFactCondition2{}
	if err := utils.UnmarshalJSON(data, &patternFactCondition2, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  PatternFactConditionTypePatternFactCondition2,
			Value: &patternFactCondition2,
		})
	}

	var patternFactCondition3 PatternFactCondition3 = PatternFactCondition3{}
	if err := utils.UnmarshalJSON(data, &patternFactCondition3, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  PatternFactConditionTypePatternFactCondition3,
			Value: &patternFactCondition3,
		})
	}

	var four Four = Four{}
	if err := utils.UnmarshalJSON(data, &four, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  PatternFactConditionTypeFour,
			Value: &four,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for PatternFactCondition", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for PatternFactCondition", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(PatternFactConditionType)
	switch best.Type {
	case PatternFactConditionTypePatternFactCondition1:
		u.PatternFactCondition1 = best.Value.(*PatternFactCondition1)
		return nil
	case PatternFactConditionTypePatternFactCondition2:
		u.PatternFactCondition2 = best.Value.(*PatternFactCondition2)
		return nil
	case PatternFactConditionTypePatternFactCondition3:
		u.PatternFactCondition3 = best.Value.(*PatternFactCondition3)
		return nil
	case PatternFactConditionTypeFour:
		u.Four = best.Value.(*Four)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for PatternFactCondition", string(data))
}

func (u PatternFactCondition) MarshalJSON() ([]byte, error) {
	if u.PatternFactCondition1 != nil {
		return utils.MarshalJSON(u.PatternFactCondition1, "", true)
	}

	if u.PatternFactCondition2 != nil {
		return utils.MarshalJSON(u.PatternFactCondition2, "", true)
	}

	if u.PatternFactCondition3 != nil {
		return utils.MarshalJSON(u.PatternFactCondition3, "", true)
	}

	if u.Four != nil {
		return utils.MarshalJSON(u.Four, "", true)
	}

	return nil, errors.New("could not marshal union type PatternFactCondition: all fields are null")
}
