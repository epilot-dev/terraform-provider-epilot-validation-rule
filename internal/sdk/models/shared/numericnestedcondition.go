// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"errors"
	"fmt"
	"github.com/epilot-dev/terraform-provider-epilot-validation-rule/internal/sdk/internal/utils"
)

type NumericNestedCondition3 struct {
	// Fact-based condition for numeric validation
	Not NumericFactCondition `json:"not"`
}

func (n NumericNestedCondition3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(n, "", false)
}

func (n *NumericNestedCondition3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &n, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (n *NumericNestedCondition3) GetNot() NumericFactCondition {
	if n == nil {
		return NumericFactCondition{}
	}
	return n.Not
}

type NumericNestedCondition2 struct {
	Any []NumericFactCondition `json:"any"`
}

func (n NumericNestedCondition2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(n, "", false)
}

func (n *NumericNestedCondition2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &n, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (n *NumericNestedCondition2) GetAny() []NumericFactCondition {
	if n == nil {
		return []NumericFactCondition{}
	}
	return n.Any
}

type NumericNestedCondition1 struct {
	All []NumericFactCondition `json:"all"`
}

func (n NumericNestedCondition1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(n, "", false)
}

func (n *NumericNestedCondition1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &n, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (n *NumericNestedCondition1) GetAll() []NumericFactCondition {
	if n == nil {
		return []NumericFactCondition{}
	}
	return n.All
}

type NumericNestedConditionType string

const (
	NumericNestedConditionTypeNumericNestedCondition1 NumericNestedConditionType = "NumericNestedCondition_1"
	NumericNestedConditionTypeNumericNestedCondition2 NumericNestedConditionType = "NumericNestedCondition_2"
	NumericNestedConditionTypeNumericNestedCondition3 NumericNestedConditionType = "NumericNestedCondition_3"
)

// NumericNestedCondition - Nested condition with logical operators (level 2 only)
type NumericNestedCondition struct {
	NumericNestedCondition1 *NumericNestedCondition1 `queryParam:"inline" union:"member"`
	NumericNestedCondition2 *NumericNestedCondition2 `queryParam:"inline" union:"member"`
	NumericNestedCondition3 *NumericNestedCondition3 `queryParam:"inline" union:"member"`

	Type NumericNestedConditionType
}

func CreateNumericNestedConditionNumericNestedCondition1(numericNestedCondition1 NumericNestedCondition1) NumericNestedCondition {
	typ := NumericNestedConditionTypeNumericNestedCondition1

	return NumericNestedCondition{
		NumericNestedCondition1: &numericNestedCondition1,
		Type:                    typ,
	}
}

func CreateNumericNestedConditionNumericNestedCondition2(numericNestedCondition2 NumericNestedCondition2) NumericNestedCondition {
	typ := NumericNestedConditionTypeNumericNestedCondition2

	return NumericNestedCondition{
		NumericNestedCondition2: &numericNestedCondition2,
		Type:                    typ,
	}
}

func CreateNumericNestedConditionNumericNestedCondition3(numericNestedCondition3 NumericNestedCondition3) NumericNestedCondition {
	typ := NumericNestedConditionTypeNumericNestedCondition3

	return NumericNestedCondition{
		NumericNestedCondition3: &numericNestedCondition3,
		Type:                    typ,
	}
}

func (u *NumericNestedCondition) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var numericNestedCondition1 NumericNestedCondition1 = NumericNestedCondition1{}
	if err := utils.UnmarshalJSON(data, &numericNestedCondition1, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  NumericNestedConditionTypeNumericNestedCondition1,
			Value: &numericNestedCondition1,
		})
	}

	var numericNestedCondition2 NumericNestedCondition2 = NumericNestedCondition2{}
	if err := utils.UnmarshalJSON(data, &numericNestedCondition2, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  NumericNestedConditionTypeNumericNestedCondition2,
			Value: &numericNestedCondition2,
		})
	}

	var numericNestedCondition3 NumericNestedCondition3 = NumericNestedCondition3{}
	if err := utils.UnmarshalJSON(data, &numericNestedCondition3, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  NumericNestedConditionTypeNumericNestedCondition3,
			Value: &numericNestedCondition3,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for NumericNestedCondition", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for NumericNestedCondition", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(NumericNestedConditionType)
	switch best.Type {
	case NumericNestedConditionTypeNumericNestedCondition1:
		u.NumericNestedCondition1 = best.Value.(*NumericNestedCondition1)
		return nil
	case NumericNestedConditionTypeNumericNestedCondition2:
		u.NumericNestedCondition2 = best.Value.(*NumericNestedCondition2)
		return nil
	case NumericNestedConditionTypeNumericNestedCondition3:
		u.NumericNestedCondition3 = best.Value.(*NumericNestedCondition3)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for NumericNestedCondition", string(data))
}

func (u NumericNestedCondition) MarshalJSON() ([]byte, error) {
	if u.NumericNestedCondition1 != nil {
		return utils.MarshalJSON(u.NumericNestedCondition1, "", true)
	}

	if u.NumericNestedCondition2 != nil {
		return utils.MarshalJSON(u.NumericNestedCondition2, "", true)
	}

	if u.NumericNestedCondition3 != nil {
		return utils.MarshalJSON(u.NumericNestedCondition3, "", true)
	}

	return nil, errors.New("could not marshal union type NumericNestedCondition: all fields are null")
}
