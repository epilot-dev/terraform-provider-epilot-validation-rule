// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"errors"
	"fmt"
	"github.com/epilot-dev/terraform-provider-epilot-validation-rule/internal/sdk/internal/utils"
)

type PatternConditionNotType string

const (
	PatternConditionNotTypePatternFactCondition   PatternConditionNotType = "PatternFactCondition"
	PatternConditionNotTypePatternNestedCondition PatternConditionNotType = "PatternNestedCondition"
)

type PatternConditionNot struct {
	PatternFactCondition   *PatternFactCondition   `queryParam:"inline" union:"member"`
	PatternNestedCondition *PatternNestedCondition `queryParam:"inline" union:"member"`

	Type PatternConditionNotType
}

func CreatePatternConditionNotPatternFactCondition(patternFactCondition PatternFactCondition) PatternConditionNot {
	typ := PatternConditionNotTypePatternFactCondition

	return PatternConditionNot{
		PatternFactCondition: &patternFactCondition,
		Type:                 typ,
	}
}

func CreatePatternConditionNotPatternNestedCondition(patternNestedCondition PatternNestedCondition) PatternConditionNot {
	typ := PatternConditionNotTypePatternNestedCondition

	return PatternConditionNot{
		PatternNestedCondition: &patternNestedCondition,
		Type:                   typ,
	}
}

func (u *PatternConditionNot) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var patternFactCondition PatternFactCondition = PatternFactCondition{}
	if err := utils.UnmarshalJSON(data, &patternFactCondition, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  PatternConditionNotTypePatternFactCondition,
			Value: &patternFactCondition,
		})
	}

	var patternNestedCondition PatternNestedCondition = PatternNestedCondition{}
	if err := utils.UnmarshalJSON(data, &patternNestedCondition, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  PatternConditionNotTypePatternNestedCondition,
			Value: &patternNestedCondition,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for PatternConditionNot", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for PatternConditionNot", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(PatternConditionNotType)
	switch best.Type {
	case PatternConditionNotTypePatternFactCondition:
		u.PatternFactCondition = best.Value.(*PatternFactCondition)
		return nil
	case PatternConditionNotTypePatternNestedCondition:
		u.PatternNestedCondition = best.Value.(*PatternNestedCondition)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for PatternConditionNot", string(data))
}

func (u PatternConditionNot) MarshalJSON() ([]byte, error) {
	if u.PatternFactCondition != nil {
		return utils.MarshalJSON(u.PatternFactCondition, "", true)
	}

	if u.PatternNestedCondition != nil {
		return utils.MarshalJSON(u.PatternNestedCondition, "", true)
	}

	return nil, errors.New("could not marshal union type PatternConditionNot: all fields are null")
}

// PatternCondition3 - NOT condition (negation)
type PatternCondition3 struct {
	Not PatternConditionNot `json:"not"`
}

func (p PatternCondition3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PatternCondition3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (p *PatternCondition3) GetNot() PatternConditionNot {
	if p == nil {
		return PatternConditionNot{}
	}
	return p.Not
}

type PatternConditionAnyType string

const (
	PatternConditionAnyTypePatternFactCondition   PatternConditionAnyType = "PatternFactCondition"
	PatternConditionAnyTypePatternNestedCondition PatternConditionAnyType = "PatternNestedCondition"
)

type PatternConditionAny struct {
	PatternFactCondition   *PatternFactCondition   `queryParam:"inline" union:"member"`
	PatternNestedCondition *PatternNestedCondition `queryParam:"inline" union:"member"`

	Type PatternConditionAnyType
}

func CreatePatternConditionAnyPatternFactCondition(patternFactCondition PatternFactCondition) PatternConditionAny {
	typ := PatternConditionAnyTypePatternFactCondition

	return PatternConditionAny{
		PatternFactCondition: &patternFactCondition,
		Type:                 typ,
	}
}

func CreatePatternConditionAnyPatternNestedCondition(patternNestedCondition PatternNestedCondition) PatternConditionAny {
	typ := PatternConditionAnyTypePatternNestedCondition

	return PatternConditionAny{
		PatternNestedCondition: &patternNestedCondition,
		Type:                   typ,
	}
}

func (u *PatternConditionAny) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var patternFactCondition PatternFactCondition = PatternFactCondition{}
	if err := utils.UnmarshalJSON(data, &patternFactCondition, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  PatternConditionAnyTypePatternFactCondition,
			Value: &patternFactCondition,
		})
	}

	var patternNestedCondition PatternNestedCondition = PatternNestedCondition{}
	if err := utils.UnmarshalJSON(data, &patternNestedCondition, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  PatternConditionAnyTypePatternNestedCondition,
			Value: &patternNestedCondition,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for PatternConditionAny", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for PatternConditionAny", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(PatternConditionAnyType)
	switch best.Type {
	case PatternConditionAnyTypePatternFactCondition:
		u.PatternFactCondition = best.Value.(*PatternFactCondition)
		return nil
	case PatternConditionAnyTypePatternNestedCondition:
		u.PatternNestedCondition = best.Value.(*PatternNestedCondition)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for PatternConditionAny", string(data))
}

func (u PatternConditionAny) MarshalJSON() ([]byte, error) {
	if u.PatternFactCondition != nil {
		return utils.MarshalJSON(u.PatternFactCondition, "", true)
	}

	if u.PatternNestedCondition != nil {
		return utils.MarshalJSON(u.PatternNestedCondition, "", true)
	}

	return nil, errors.New("could not marshal union type PatternConditionAny: all fields are null")
}

// PatternCondition2 - Any conditions must be true (OR logic)
type PatternCondition2 struct {
	Any []PatternConditionAny `json:"any"`
}

func (p PatternCondition2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PatternCondition2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (p *PatternCondition2) GetAny() []PatternConditionAny {
	if p == nil {
		return []PatternConditionAny{}
	}
	return p.Any
}

type PatternConditionAllType string

const (
	PatternConditionAllTypePatternFactCondition   PatternConditionAllType = "PatternFactCondition"
	PatternConditionAllTypePatternNestedCondition PatternConditionAllType = "PatternNestedCondition"
)

type PatternConditionAll struct {
	PatternFactCondition   *PatternFactCondition   `queryParam:"inline" union:"member"`
	PatternNestedCondition *PatternNestedCondition `queryParam:"inline" union:"member"`

	Type PatternConditionAllType
}

func CreatePatternConditionAllPatternFactCondition(patternFactCondition PatternFactCondition) PatternConditionAll {
	typ := PatternConditionAllTypePatternFactCondition

	return PatternConditionAll{
		PatternFactCondition: &patternFactCondition,
		Type:                 typ,
	}
}

func CreatePatternConditionAllPatternNestedCondition(patternNestedCondition PatternNestedCondition) PatternConditionAll {
	typ := PatternConditionAllTypePatternNestedCondition

	return PatternConditionAll{
		PatternNestedCondition: &patternNestedCondition,
		Type:                   typ,
	}
}

func (u *PatternConditionAll) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var patternFactCondition PatternFactCondition = PatternFactCondition{}
	if err := utils.UnmarshalJSON(data, &patternFactCondition, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  PatternConditionAllTypePatternFactCondition,
			Value: &patternFactCondition,
		})
	}

	var patternNestedCondition PatternNestedCondition = PatternNestedCondition{}
	if err := utils.UnmarshalJSON(data, &patternNestedCondition, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  PatternConditionAllTypePatternNestedCondition,
			Value: &patternNestedCondition,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for PatternConditionAll", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for PatternConditionAll", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(PatternConditionAllType)
	switch best.Type {
	case PatternConditionAllTypePatternFactCondition:
		u.PatternFactCondition = best.Value.(*PatternFactCondition)
		return nil
	case PatternConditionAllTypePatternNestedCondition:
		u.PatternNestedCondition = best.Value.(*PatternNestedCondition)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for PatternConditionAll", string(data))
}

func (u PatternConditionAll) MarshalJSON() ([]byte, error) {
	if u.PatternFactCondition != nil {
		return utils.MarshalJSON(u.PatternFactCondition, "", true)
	}

	if u.PatternNestedCondition != nil {
		return utils.MarshalJSON(u.PatternNestedCondition, "", true)
	}

	return nil, errors.New("could not marshal union type PatternConditionAll: all fields are null")
}

// PatternCondition1 - All conditions must be true (AND logic)
type PatternCondition1 struct {
	All []PatternConditionAll `json:"all"`
}

func (p PatternCondition1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PatternCondition1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (p *PatternCondition1) GetAll() []PatternConditionAll {
	if p == nil {
		return []PatternConditionAll{}
	}
	return p.All
}

type PatternConditionType string

const (
	PatternConditionTypePatternCondition1 PatternConditionType = "PatternCondition_1"
	PatternConditionTypePatternCondition2 PatternConditionType = "PatternCondition_2"
	PatternConditionTypePatternCondition3 PatternConditionType = "PatternCondition_3"
)

// PatternCondition - Condition definition for a pattern-based validation rule (2 levels deep)
type PatternCondition struct {
	PatternCondition1 *PatternCondition1 `queryParam:"inline" union:"member"`
	PatternCondition2 *PatternCondition2 `queryParam:"inline" union:"member"`
	PatternCondition3 *PatternCondition3 `queryParam:"inline" union:"member"`

	Type PatternConditionType
}

func CreatePatternConditionPatternCondition1(patternCondition1 PatternCondition1) PatternCondition {
	typ := PatternConditionTypePatternCondition1

	return PatternCondition{
		PatternCondition1: &patternCondition1,
		Type:              typ,
	}
}

func CreatePatternConditionPatternCondition2(patternCondition2 PatternCondition2) PatternCondition {
	typ := PatternConditionTypePatternCondition2

	return PatternCondition{
		PatternCondition2: &patternCondition2,
		Type:              typ,
	}
}

func CreatePatternConditionPatternCondition3(patternCondition3 PatternCondition3) PatternCondition {
	typ := PatternConditionTypePatternCondition3

	return PatternCondition{
		PatternCondition3: &patternCondition3,
		Type:              typ,
	}
}

func (u *PatternCondition) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var patternCondition1 PatternCondition1 = PatternCondition1{}
	if err := utils.UnmarshalJSON(data, &patternCondition1, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  PatternConditionTypePatternCondition1,
			Value: &patternCondition1,
		})
	}

	var patternCondition2 PatternCondition2 = PatternCondition2{}
	if err := utils.UnmarshalJSON(data, &patternCondition2, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  PatternConditionTypePatternCondition2,
			Value: &patternCondition2,
		})
	}

	var patternCondition3 PatternCondition3 = PatternCondition3{}
	if err := utils.UnmarshalJSON(data, &patternCondition3, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  PatternConditionTypePatternCondition3,
			Value: &patternCondition3,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for PatternCondition", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestUnionCandidate(candidates, data)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for PatternCondition", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(PatternConditionType)
	switch best.Type {
	case PatternConditionTypePatternCondition1:
		u.PatternCondition1 = best.Value.(*PatternCondition1)
		return nil
	case PatternConditionTypePatternCondition2:
		u.PatternCondition2 = best.Value.(*PatternCondition2)
		return nil
	case PatternConditionTypePatternCondition3:
		u.PatternCondition3 = best.Value.(*PatternCondition3)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for PatternCondition", string(data))
}

func (u PatternCondition) MarshalJSON() ([]byte, error) {
	if u.PatternCondition1 != nil {
		return utils.MarshalJSON(u.PatternCondition1, "", true)
	}

	if u.PatternCondition2 != nil {
		return utils.MarshalJSON(u.PatternCondition2, "", true)
	}

	if u.PatternCondition3 != nil {
		return utils.MarshalJSON(u.PatternCondition3, "", true)
	}

	return nil, errors.New("could not marshal union type PatternCondition: all fields are null")
}
