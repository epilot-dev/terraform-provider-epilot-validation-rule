// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"errors"
	"fmt"
	"github.com/epilot-dev/terraform-provider-epilot-validation-rule/internal/sdk/internal/utils"
)

type PatternConditionNotType string

const (
	PatternConditionNotTypePatternFactCondition   PatternConditionNotType = "PatternFactCondition"
	PatternConditionNotTypePatternNestedCondition PatternConditionNotType = "PatternNestedCondition"
)

type PatternConditionNot struct {
	PatternFactCondition   *PatternFactCondition   `queryParam:"inline" name:"not"`
	PatternNestedCondition *PatternNestedCondition `queryParam:"inline" name:"not"`

	Type PatternConditionNotType
}

func CreatePatternConditionNotPatternFactCondition(patternFactCondition PatternFactCondition) PatternConditionNot {
	typ := PatternConditionNotTypePatternFactCondition

	return PatternConditionNot{
		PatternFactCondition: &patternFactCondition,
		Type:                 typ,
	}
}

func CreatePatternConditionNotPatternNestedCondition(patternNestedCondition PatternNestedCondition) PatternConditionNot {
	typ := PatternConditionNotTypePatternNestedCondition

	return PatternConditionNot{
		PatternNestedCondition: &patternNestedCondition,
		Type:                   typ,
	}
}

func (u *PatternConditionNot) UnmarshalJSON(data []byte) error {

	var patternFactCondition PatternFactCondition = PatternFactCondition{}
	if err := utils.UnmarshalJSON(data, &patternFactCondition, "", true, nil); err == nil {
		u.PatternFactCondition = &patternFactCondition
		u.Type = PatternConditionNotTypePatternFactCondition
		return nil
	}

	var patternNestedCondition PatternNestedCondition = PatternNestedCondition{}
	if err := utils.UnmarshalJSON(data, &patternNestedCondition, "", true, nil); err == nil {
		u.PatternNestedCondition = &patternNestedCondition
		u.Type = PatternConditionNotTypePatternNestedCondition
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for PatternConditionNot", string(data))
}

func (u PatternConditionNot) MarshalJSON() ([]byte, error) {
	if u.PatternFactCondition != nil {
		return utils.MarshalJSON(u.PatternFactCondition, "", true)
	}

	if u.PatternNestedCondition != nil {
		return utils.MarshalJSON(u.PatternNestedCondition, "", true)
	}

	return nil, errors.New("could not marshal union type PatternConditionNot: all fields are null")
}

// PatternCondition3 - NOT condition (negation)
type PatternCondition3 struct {
	Not PatternConditionNot `json:"not"`
}

func (p PatternCondition3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PatternCondition3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"not"}); err != nil {
		return err
	}
	return nil
}

func (o *PatternCondition3) GetNot() PatternConditionNot {
	if o == nil {
		return PatternConditionNot{}
	}
	return o.Not
}

type PatternConditionAnyType string

const (
	PatternConditionAnyTypePatternFactCondition   PatternConditionAnyType = "PatternFactCondition"
	PatternConditionAnyTypePatternNestedCondition PatternConditionAnyType = "PatternNestedCondition"
)

type PatternConditionAny struct {
	PatternFactCondition   *PatternFactCondition   `queryParam:"inline" name:"any"`
	PatternNestedCondition *PatternNestedCondition `queryParam:"inline" name:"any"`

	Type PatternConditionAnyType
}

func CreatePatternConditionAnyPatternFactCondition(patternFactCondition PatternFactCondition) PatternConditionAny {
	typ := PatternConditionAnyTypePatternFactCondition

	return PatternConditionAny{
		PatternFactCondition: &patternFactCondition,
		Type:                 typ,
	}
}

func CreatePatternConditionAnyPatternNestedCondition(patternNestedCondition PatternNestedCondition) PatternConditionAny {
	typ := PatternConditionAnyTypePatternNestedCondition

	return PatternConditionAny{
		PatternNestedCondition: &patternNestedCondition,
		Type:                   typ,
	}
}

func (u *PatternConditionAny) UnmarshalJSON(data []byte) error {

	var patternFactCondition PatternFactCondition = PatternFactCondition{}
	if err := utils.UnmarshalJSON(data, &patternFactCondition, "", true, nil); err == nil {
		u.PatternFactCondition = &patternFactCondition
		u.Type = PatternConditionAnyTypePatternFactCondition
		return nil
	}

	var patternNestedCondition PatternNestedCondition = PatternNestedCondition{}
	if err := utils.UnmarshalJSON(data, &patternNestedCondition, "", true, nil); err == nil {
		u.PatternNestedCondition = &patternNestedCondition
		u.Type = PatternConditionAnyTypePatternNestedCondition
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for PatternConditionAny", string(data))
}

func (u PatternConditionAny) MarshalJSON() ([]byte, error) {
	if u.PatternFactCondition != nil {
		return utils.MarshalJSON(u.PatternFactCondition, "", true)
	}

	if u.PatternNestedCondition != nil {
		return utils.MarshalJSON(u.PatternNestedCondition, "", true)
	}

	return nil, errors.New("could not marshal union type PatternConditionAny: all fields are null")
}

// PatternCondition2 - Any conditions must be true (OR logic)
type PatternCondition2 struct {
	Any []PatternConditionAny `json:"any"`
}

func (p PatternCondition2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PatternCondition2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"any"}); err != nil {
		return err
	}
	return nil
}

func (o *PatternCondition2) GetAny() []PatternConditionAny {
	if o == nil {
		return []PatternConditionAny{}
	}
	return o.Any
}

type PatternConditionAllType string

const (
	PatternConditionAllTypePatternFactCondition   PatternConditionAllType = "PatternFactCondition"
	PatternConditionAllTypePatternNestedCondition PatternConditionAllType = "PatternNestedCondition"
)

type PatternConditionAll struct {
	PatternFactCondition   *PatternFactCondition   `queryParam:"inline" name:"all"`
	PatternNestedCondition *PatternNestedCondition `queryParam:"inline" name:"all"`

	Type PatternConditionAllType
}

func CreatePatternConditionAllPatternFactCondition(patternFactCondition PatternFactCondition) PatternConditionAll {
	typ := PatternConditionAllTypePatternFactCondition

	return PatternConditionAll{
		PatternFactCondition: &patternFactCondition,
		Type:                 typ,
	}
}

func CreatePatternConditionAllPatternNestedCondition(patternNestedCondition PatternNestedCondition) PatternConditionAll {
	typ := PatternConditionAllTypePatternNestedCondition

	return PatternConditionAll{
		PatternNestedCondition: &patternNestedCondition,
		Type:                   typ,
	}
}

func (u *PatternConditionAll) UnmarshalJSON(data []byte) error {

	var patternFactCondition PatternFactCondition = PatternFactCondition{}
	if err := utils.UnmarshalJSON(data, &patternFactCondition, "", true, nil); err == nil {
		u.PatternFactCondition = &patternFactCondition
		u.Type = PatternConditionAllTypePatternFactCondition
		return nil
	}

	var patternNestedCondition PatternNestedCondition = PatternNestedCondition{}
	if err := utils.UnmarshalJSON(data, &patternNestedCondition, "", true, nil); err == nil {
		u.PatternNestedCondition = &patternNestedCondition
		u.Type = PatternConditionAllTypePatternNestedCondition
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for PatternConditionAll", string(data))
}

func (u PatternConditionAll) MarshalJSON() ([]byte, error) {
	if u.PatternFactCondition != nil {
		return utils.MarshalJSON(u.PatternFactCondition, "", true)
	}

	if u.PatternNestedCondition != nil {
		return utils.MarshalJSON(u.PatternNestedCondition, "", true)
	}

	return nil, errors.New("could not marshal union type PatternConditionAll: all fields are null")
}

// PatternCondition1 - All conditions must be true (AND logic)
type PatternCondition1 struct {
	All []PatternConditionAll `json:"all"`
}

func (p PatternCondition1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PatternCondition1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"all"}); err != nil {
		return err
	}
	return nil
}

func (o *PatternCondition1) GetAll() []PatternConditionAll {
	if o == nil {
		return []PatternConditionAll{}
	}
	return o.All
}

type PatternConditionType string

const (
	PatternConditionTypePatternCondition1 PatternConditionType = "PatternCondition_1"
	PatternConditionTypePatternCondition2 PatternConditionType = "PatternCondition_2"
	PatternConditionTypePatternCondition3 PatternConditionType = "PatternCondition_3"
)

// PatternCondition - Condition definition for a pattern-based validation rule (2 levels deep)
type PatternCondition struct {
	PatternCondition1 *PatternCondition1 `queryParam:"inline" name:"PatternCondition"`
	PatternCondition2 *PatternCondition2 `queryParam:"inline" name:"PatternCondition"`
	PatternCondition3 *PatternCondition3 `queryParam:"inline" name:"PatternCondition"`

	Type PatternConditionType
}

func CreatePatternConditionPatternCondition1(patternCondition1 PatternCondition1) PatternCondition {
	typ := PatternConditionTypePatternCondition1

	return PatternCondition{
		PatternCondition1: &patternCondition1,
		Type:              typ,
	}
}

func CreatePatternConditionPatternCondition2(patternCondition2 PatternCondition2) PatternCondition {
	typ := PatternConditionTypePatternCondition2

	return PatternCondition{
		PatternCondition2: &patternCondition2,
		Type:              typ,
	}
}

func CreatePatternConditionPatternCondition3(patternCondition3 PatternCondition3) PatternCondition {
	typ := PatternConditionTypePatternCondition3

	return PatternCondition{
		PatternCondition3: &patternCondition3,
		Type:              typ,
	}
}

func (u *PatternCondition) UnmarshalJSON(data []byte) error {

	var patternCondition1 PatternCondition1 = PatternCondition1{}
	if err := utils.UnmarshalJSON(data, &patternCondition1, "", true, nil); err == nil {
		u.PatternCondition1 = &patternCondition1
		u.Type = PatternConditionTypePatternCondition1
		return nil
	}

	var patternCondition2 PatternCondition2 = PatternCondition2{}
	if err := utils.UnmarshalJSON(data, &patternCondition2, "", true, nil); err == nil {
		u.PatternCondition2 = &patternCondition2
		u.Type = PatternConditionTypePatternCondition2
		return nil
	}

	var patternCondition3 PatternCondition3 = PatternCondition3{}
	if err := utils.UnmarshalJSON(data, &patternCondition3, "", true, nil); err == nil {
		u.PatternCondition3 = &patternCondition3
		u.Type = PatternConditionTypePatternCondition3
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for PatternCondition", string(data))
}

func (u PatternCondition) MarshalJSON() ([]byte, error) {
	if u.PatternCondition1 != nil {
		return utils.MarshalJSON(u.PatternCondition1, "", true)
	}

	if u.PatternCondition2 != nil {
		return utils.MarshalJSON(u.PatternCondition2, "", true)
	}

	if u.PatternCondition3 != nil {
		return utils.MarshalJSON(u.PatternCondition3, "", true)
	}

	return nil, errors.New("could not marshal union type PatternCondition: all fields are null")
}
